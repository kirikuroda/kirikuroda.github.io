```{r, include=FALSE}
source("common.R")
```

# (PART\*) データハンドリング {-}

# データハンドリング {#data-handling}

ここまで、ggplot2を使ったデータの可視化を見てきた。ただし、ggplot2で作図をする際、大きな前提条件がある。それは、<u>**データを行列の形で用意しなければいけない**</u>というものである。つまり、変数を列に、観測値を行に取るようなデータ構造にあらかじめ整形しなければならないということである。

たとえば、今まで使ってきた`mtcars`、`faithful`のデータ構造を改めて見てみよう。

```{r}
head(mtcars) # 先頭6行
```

```{r}
head(faithful) # 先頭6行
```

どちらも、列に変数名、行に観測値という構造をもっている。

---

散布図、箱ひげ図、ヒストグラムのように、これらのデータの素値をプロットする際、データハンドリングはあまり問題にならない。しかし、実際は平均値や標準誤差のように、何かしらの統計的処理を施した値をプロットしたいこともある。また、ある1つのグループのデータだけをプロットしたいという場合もある。

可視化の際に直面する問題は、おおよそ以下の3つに大別できるだろう。

- 1つのグループのデータだけを抽出した上でプロットしたい（たとえば、3条件のうち統制条件だけプロットしたい、など）

- 素値ではなく、平均値や標準誤差などの統計量をプロットしたい

- 2つ以上のデータフレームを結合してプロットしたい

などである。


## tidyverse

データハンドリングに使うパッケージ群（複数のパッケージ）はtidyverseと呼ばれており、`library(tidyverse)`で読み込むことができる。ちなみにggplot2もtidyverseの一部なので、自動的に読み込まれる。下のコードを実行すると色々メッセージが出るかもしれないが、気にしなくて良い。

```{r, message=FALSE}
library(tidyverse) # データハンドリング用のパッケージおよびggplot2を読み込む
```

この章では、主にggplot2の`mpg`（自動車のデータ）を使い、データハンドリングを見ていくことにする。


## 抽出

### データの値で絞り込み

データの値によって絞り込みを行いたい時がある。たとえば、`mpg`であれば、`manufacturer`の種類でデータを絞り込みたい（データの行単位で抽出したい）ということである。実際の実験データで言えば、男性／女性のデータのみ抽出したいというような場面である。

このようなときは、`filter(抽出条件)`を使えば良い。

```{r}
mpg %>%
  filter(manufacturer == "audi") # manufacturerが"audi"のものだけを抽出
```

ここで、`==`は「等しい」ということを意味している。大体のプログラミング言語では、`==`が「等しい」`=`が「代入する」を意味するものである。

ちなみに、`%>%`はパイプ演算子と呼ばれており、オブジェクトを次の関数の第一引数に突っ込むという操作を表している。ちょっと何を言っているのか分からないと思うが、あまり気にしなくて良い。何をやっているのか、少なくとも直観的には分かるだろう。今はそれで大丈夫である。

---

複数条件で絞り込むこともできる。たとえば、「`manufacturer`が`"audi"`」<u>**かつ**</u>「`model`が`"a4"`」の行を抽出したい場合は、条件を`&`で繋げば良い。

```{r}
mpg %>%
  filter(manufacturer == "audi" & model == "a4")
```

<br>

「`manufacturer`が`"audi"`」<u>**または**</u>「`model`が`"a4"`」の行を抽出したい場合は、条件を`|`で繋げば良い。

```{r}
mpg %>%
  filter(manufacturer == "audi" | model == "a4")
```

<br>

「`manufacturer`が`"audi"`」<u>**でもなく**</u>「`model`が`"a4"`」<u>**でもない**</u>行を抽出したい場合は、条件を`!()`で囲めば良い。`!()`は論理値を反転させる演算子である^[ちなみに「`manufacturer`が`"audi"`ではない」を書きたいときは、`manufacturer != "audi"`とすれば良い。]。

```{r}
mpg %>%
  filter(!(manufacturer == "audi" | model == "a4"))
```

### データの列で絞り込み

では、列方向で抽出するにはどうすれば良いのだろうか？　たとえば、`mpg`で言えば、`manufacturer`と`model`と`trans`と`drv`の列を抽出したいというような状況である。

このようなときは、`select(抽出したい列名)`を使えば良い。抽出したい列名は、1つだけに限らず、何個書いても問題ない。

```{r}
mpg %>%
  select(manufacturer, model, trans, drv) # 4つの列を抽出
```

<br>

`select()`では、「A列からG列まで」というような抽出も可能である。

```{r}
mpg %>%
  select(manufacturer:drv) # manufacturerからdrvまでの7列を抽出
```

<br>

指定した列を除外することもできる`select(-列名)`とすれば良い。

```{r}
mpg %>%
  select(-manufacturer) # manufacturerを除外
```


## 追加

### 新しい列を追加

データフレームに新しい列を作るには、`mutate(新しく作る列名 = 値)`を使えば良い。

```{r}
mpg %>%
  mutate(one = 1) # 最後尾にoneという列を追加した
```

<br>

上の例では`one`という列を作り、すべての行を1で埋めたが、これはあまり実践的ではない。

`mutate()`が力を発揮するのは、特に`if_else()`という関数と組み合わせたときである。たとえば、`displ`（排気量）の値が3未満なら`good`、3以上なら`bad`という列（`engine`）を作りたい場合、以下のように書けば良い。

```{r}
mpg %>%
  mutate(engine = if_else(displ < 3, "good", "bad"))
```


### 列名を変更

新しい列を作りたいわけではないが、列名を変えたい場合がある。このようなときは、`rename(新しい列名 = 古い列名)`を使えば良い。

```{r}
mpg %>%
  rename(nen = year) # yearをnenに変更
```

## 集約

統計量の算出に使えるのは、`group_by()`と`summarise()`である。

まずは`summarise()`を見てみよう。書き方は`summarise(新しい列名 = 関数)`である。同時に複数の関数を使うこともできる。たとえば、`displ`の平均値、標準偏差、最小値、最大値を計算したい場合、以下のように書けば良い。

```{r}
mpg %>%
  summarise(mean_displ = mean(displ),
            sd_displ = sd(displ),
            min_displ = min(displ),
            max_displ = max(displ))
```

このように、`summarise()`を使うと、データ全体の統計量を計算することができる。

---

しかし、実際の場面で全体の統計量を計算することは少なく、むしろグループごとの統計量を計算したいという場面のほうが圧倒的に多いだろう。

このようなときは、`group_by(グルーピングの変数)`を使うことができる。たとえば、`year`ごとに`summarise()`を実行するには、以下のように書けば良い。

```{r}
mpg %>%
  group_by(year) %>%
  summarise(mean_displ = mean(displ),
            sd_displ = sd(displ),
            min_displ = min(displ),
            max_displ = max(displ))
```

製造年（1999年と2008年）ごとに統計量を計算することができた。


## 結合

ここでは、`mpg`ではなく、架空のデータセットを作ってみよう。たとえば、以下のような状況を考えてみてほしい。

<br>

>たかし君とはなこさんは、以前見たテレビドラマを思い出して「足袋を履いたときと、裸足のときとで、どっちが走るのが早くなるだろうか？」と疑問に思いました。そこで2人は、5日間のうち3日は足袋を履いて、2日は裸足で自宅から学校まで走り、到着までの所要時間を測りました。

<br>

2人の毎日の所要時間データは`commute`というデータフレームとして保存しよう。

```{r}
commute = data.frame(
  "name" = c("takashi","takashi","takashi","takashi","takashi","hanako","hanako","hanako","hanako","hanako"),
  "day" = c(1,2,3,4,5,1,2,3,4,5),
  "time" = c(10,13,12,11,14,9,15,14,10,16)
)

commute
```

一方、足袋だったか裸足だったかは、`shoes`というデータフレームとして保存しよう。

```{r}
shoes = data.frame(
  "day" = c(1,2,3,4,5),
  "shoes" = c("tabi","tabi","bare","tabi","bare")
)

shoes
```

<br>

このようなとき、所要時間のデータと毎日の靴のデータを関係づけて可視化したいものである。しかし、別々のデータフレームとして保存されているので、今のままでは可視化できない。

このようなときは、`inner_join()`という関数を使えば良い。書き方は、`inner_join(結合するデータ, by = "共通の列名")`である。今回は、`day`という変数が共通なので、以下のように書けば良い。

```{r}
commute %>%
  inner_join(shoes, by = "day")
```

無事2つのデータを結合することができた。

---

しかし、いつも共通の列名があるわけではない。たとえば、`shoes`が以下のようになっていたとしよう。

```{r}
shoes = data.frame(
  "hinichi" = c(1,2,3,4,5), # "day"ではなく、"hinichi"という列名
  "shoes" = c("tabi","tabi","bare","tabi","bare")
)

shoes
```

このようなときは、以下のように書けば良い。

```{r}
commute %>%
  inner_join(shoes, by = c("day" = "hinichi")) # dayとhinichiを対応づけている
```

この他にも`left_join()`、`right_join()`などの関数がある。詳しくは、https://dplyr.tidyverse.org/reference/join.html を見てほしい。


## ロングフォーマット

以下の架空のデータフレーム（X, Y, Zという3つの株価の増減比の時系列データ）があるとしよう。

```{r}
set.seed(1)
stocks = data.frame(
  time = as.Date('2009-01-01') + 0:9,
  X = rnorm(10, 0, 1),
  Y = rnorm(10, 0, 2),
  Z = rnorm(10, 0, 4)
)

stocks

```

<br>

このとき、3つの株価の時系列変化をプロットしてみたいが、このままではうまくいかない。なぜなら、データがロングフォーマット（列に変数名、行にデータ）という形式になっていないからである。このようなデータをワイドフォーマットと言う。

データをロングフォーマットに変えるには、`gather()`を使えば良い。書き方は、`gather(key = "新しく作るラベル", value = "新しく作る数値", ロングにしたい列（複数個）)`である。文章ではわかりにくいと思うので、以下のコードを見てほしい。

```{r}
stocks_long = stocks %>%
  gather(key = stock, value = price, X, Y, Z) # X:Zで指定してもOK

stocks_long

```

ロングフォーマットにすることができた。

---

元のワイドフォーマットに戻したい場合は、`spread()`を使えば良い。書き方は`spread(key = ワイドにする列, value = ワイドにする値)`である。これも文章ではわかりにくいと思うので、以下のコードを見てほしい。

```{r}
stocks_long %>%
  spread(stock, price)
```

ワイドフォーマットに戻すことができた。

## データファイルの読み込み

実際のデータファイル（たとえばcsv、tsv、xlsxなどのスプレッドシート）は、`read_csv()`や`read_tsv()`、readxlパッケージの`read_excel()`で読み込むことができる。

データの読み込みについては、各人の都合があると思うので、周りの人に尋ねてみてほしい^[「言語化して説明するのが大変」とは言えない。]。

## ggplot2と一緒に使う

パイプ演算子（`%>%`）を使うと、以下のようにデータハンドリングと可視化をシームレスにつなげることができる。下の例では、平均値と標準誤差をグループごとに計算し、棒グラフとエラーバーを描いている。

```{r}
mpg %>%
  group_by(year) %>% # yearごとに
  summarise(mean = mean(displ),
            se = sd(displ) / sqrt(n())) %>% # 平均値と標準誤差を計算；n()はデータの個数を数える関数
  ggplot(aes(factor(year), mean, fill = factor(year))) + # dataは「%>%」で自動的に流し込まれているので、指定しなくて良い
  geom_bar(stat = "identity") +
  geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.2)
```
