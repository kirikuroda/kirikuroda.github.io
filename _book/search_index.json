[
["index.html", "いつか役に立つかもしれない資料 はじめに（服用上の注意）", " いつか役に立つかもしれない資料 Kiri Kuroda はじめに（服用上の注意） 効能：データの性質を他人にわかりやすく伝えられるようになる。 対象：卒論等で（コンテンツはさておいて）わかりやすく、なんとなく見栄えの良いレポート・発表をしたいと思ってはいるけれど、どこから手を着ければいいかわからない人。 注意：読んでいてわからないことに出くわした場合、とりあえずググってみること。おそらく検索能力も重要なスキルである。周りの人に尋ねてみるのも推奨。 "],
["rrstudio.html", "RとRStudioのセットアップ 0.1 Rのインストール 0.2 RStudioのインストール 0.3 パッケージのインストール 0.4 パッケージの読み込み 0.5 どうやってRのコードを実行するか？", " RとRStudioのセットアップ 以下の手順でセットアップしてほしい。どこかでつまずいたら、とにかく周りの人に聞いてみよう1。 0.1 Rのインストール https://cran.r-project.org にアクセスし、自分のパソコンのOSに合ったものをインストールする。 0.2 RStudioのインストール https://www.rstudio.com にアクセスし、RStudioをインストールする。インストールの際は、“Free”と書かれているものを選ぶようにすること。 0.3 パッケージのインストール RとRStudioが揃っても、「パッケージ」というものがないと話にならない。RとRStudioをiOSやAndroidとすれば、パッケージはアプリのようなものである。パッケージのインストールはinstall.packages(&quot;パッケージ名)で実行できる。install.packages()は1度だけ行えば良い。 以下のコードをコンソールに入力して実行しよう。 # 本資料で使うパッケージのインストール install.packages(c(&quot;tidyverse&quot;,&quot;gcookbook&quot;,&quot;GGally&quot;,&quot;devtools&quot;)) 0.4 パッケージの読み込み パッケージはインストールできたが、それだけでは十分ではない。RStudioを立ち上げるたびにパッケージを読み込まなくてはいけないのである。library(パッケージ名)でパッケージを読み込むことができる。 library(tidyverse) # 例：色々メッセージが出てくるが、気にしなくて良い 0.5 どうやってRのコードを実行するか？ 文章化するのが予想以上に面倒だったので、説明は他に譲る（……）。たとえば、https://kazutan.github.io/JSSP2018_spring/intro_rstudio.html が参考になるだろう。個人的には、R Markdownという記法がレポーティングに最適だと思うが、現時点では気になる人だけ調べれば良いと思う。 何にでも（卒論にも）当てはまるが、自分から尋ねない限り、誰も手は差し伸べてくれないものである。逆に言えば、何か尋ねさえすれば、答えてくれない人はいないものである。↩ "],
["introduction.html", "1 可視化の重要性 1.1 アンスコムの例 1.2 可視化のツール：ggplot2", " 1 可視化の重要性 データの可視化（≒作図）はデータ分析において不可欠である。むしろ、統計的分析より重要なこともしばしばである。「言うほど重要か？」と思う人がいるかもしれないので、有名な「アンスコムの例（Anscombe’s quartet）」を使ってそれを例証してみよう。 1.1 アンスコムの例 仮に4人の学生が同じ実験を実施したとする（それぞれ実験I, II, III, IV）。その実験では参加者（各11名）の個人傾向を様々な尺度で測定しており、ここでは変数「x」と「y」が測定されたと考えてみてほしい（変数は別に「x」と「y」である必要はなく、「身長」と「体重」などでも良い）。 4人はそれぞれの実験における変数xとyの平均値（mean; M）と標準偏差（standard deviation; SD）と相関係数（correlation coefficient; r）を計算し、ゼミで報告した（下の表は適当に解読してほしい）。 experiment mean_x sd_x mean_y sd_y pearson_r I 9 3.316625 7.500909 2.031568 0.8164205 II 9 3.316625 7.500909 2.031657 0.8162365 III 9 3.316625 7.500000 2.030424 0.8162867 IV 9 3.316625 7.500909 2.030579 0.8165214 この表からわかるように、どの実験でもxとyの平均値、標準偏差、相関係数はほとんど同じだった。 …… という報告を私たちはついついやりがちである。しかし、これらの報告はデータの重要な性質を見落としている。 では、ここでxとyの散布図を描いてみよう。 Figure 1.1: 「アンスコムの例」の散布図。どの変数も統計量（平均値、標準偏差、相関係数）の上では同じだが、実際は明らかに異なるパターンを示していることがひと目でわかる。 上の図を見てひと目でわかるように、xとyの平均値、標準偏差、相関係数が同じであるにもかかわらず、各実験のデータは全く異なる様相を呈していた。 このように、可視化は非常に強力なデータ分析手法の一つである（スプレッドシートの数字だけを見て、これらの図を頭に思い浮かべられる人はいるだろうか？）。また、この例は可視化の本質を私たちに教えてくれる。その本質とは、 変数の数量や分布（distribution）がひと目で分かる 変数間の関係（association）がひと目でわかる ということである。少し乱暴にまとめてしまうと、グラフとは変数の分布や関係を可視化したものにほかならない。 「ひと目でわかる」という点も重要である。もし発表者が表や統計量だけを見せ、それをもとに議論を始めたら、あなたはどのように感じるだろうか？ 数字ばかり見せられた聴衆は大体話をフォローできなくなるし、そもそも最初から聞く耳を持たなくなってしまう場合もある。ヒトの認知資源には限りがあるし、わかりにくい話にずっと耳を貸していられるほど人々は親切でもないと思っておいたほうが賢明だろう。 とにかく、まずは黙って「可視化からはじめよ」を肝に銘じてほしい。 1.2 可視化のツール：ggplot2 さて、データ分析＋論文用の可視化にはRという統計ソフトのggplot2というパッケージ（tidyverseというパッケージ群の1つ）が便利である。逆に言えば、tidyverseやggplot2がなければRを使うメリットは見いだせないと言っても過言ではない。 ggplot2がなぜ便利なのかを一言で説明するのは難しいが、なぜ他のツールーーたとえばEx○elーーが不便なのかはすぐに列挙できる。 作図が面倒 美しくない（ugly!） 再現性に欠ける（グラフの縦横比、色、コピペ汚染） ……などなど。他にもあるかもしれない。 しかし、あまり悪口ばかり書いても仕方がないので、早速Rとggplot2を使ってみることにしよう。 "],
["tutorial.html", "2 チュートリアル 2.1 早速手を動かす 2.2 まとめ", " 2 チュートリアル 2.1 早速手を動かす まず、データ可視化用のパッケージであるggplot2を読み込んでみよう。パッケージはlibrary(パッケージ名)で読み込むことができる。 library(ggplot2) # ※シャープ記号より後ろに書かれている内容はただのコメントアウト（＝注釈） # コメントアウトなので何を書いても怒られない # ハッシュタグではない # 自分でコードを書くときはメモとして使うようにしよう チュートリアル用のデータとして、Rにデフォルトで入っているmtcarsを使うことにする。mtcarsは自動車の燃費などに関するデータである（コンソールに?mtcarsと入力すると詳細なヘルプをみることができる）。では、str(データ)で中身を確認してみよう。 str(mtcars) # 中身を確認 ## &#39;data.frame&#39;: 32 obs. of 11 variables: ## $ mpg : num 21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ... ## $ cyl : num 6 6 4 6 8 6 8 4 4 6 ... ## $ disp: num 160 160 108 258 360 ... ## $ hp : num 110 110 93 110 175 105 245 62 95 123 ... ## $ drat: num 3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ... ## $ wt : num 2.62 2.88 2.32 3.21 3.44 ... ## $ qsec: num 16.5 17 18.6 19.4 17 ... ## $ vs : num 0 0 1 1 0 1 0 1 1 1 ... ## $ am : num 1 1 1 0 0 0 0 0 0 0 ... ## $ gear: num 4 4 4 3 3 3 3 4 4 4 ... ## $ carb: num 4 4 1 1 2 1 4 2 2 4 ... 11の変数（variable）と32の観測値（observation）が記録されている。32行×11列のスプレッドシートがあるのと同じ状態だと考えてほしい。head(データ)で先頭6行のデータを確認してみよう。 head(mtcars) # 先頭6行を確認 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 変数は全部で11個あるが、まずは2つの変数に注目してみよう。その変数は、 disp：エンジンの排気量（立方インチ） mpg：燃費（マイル／ガロン） である。 素朴に思いつくのは、「排気量と燃費の相関関係はどうなっているか？」というものだろう。排気量と燃費はそれぞれ連続変数（continuous variable：量的変数、quantitative variableとも言う）なので、ここは散布図を描くのが妥当そうである。 では、ggplot2における可視化を、手順を追って見ていこう。 1. x軸とy軸にどの変数を対応づけたいかを考える ggplot2でデータを可視化する際、最初に書かなければいけない基本のコードはggplot(data = データ, aes(x = x軸の変数, y = y軸の変数))である。 ggplot(data = mtcars, aes(x = disp, y = mpg)) Figure 2.1: 背景のみのグラフ。 しかし、灰色の背景があるだけでデータはプロットされない。なぜなら、どのようなデザイン2でデータをプロットするかを指示していないからである。つまり、これだけではまだ足りない。 2. どのようなデザインでプロットしたいかを指示する データをどのようなデザイン（geometry）でプロットしたいかを、geom_xxxx()で指定しなければならない。今回は散布図（データを点としてプロット）なので、geom_point()というコードを使う。 先程のコードに「+」でコードをつなげていくことでプロットできるようになる。 ggplot(data = mtcars, aes(x = disp, y = mpg)) + # コードを読みやすくするため、「+」のところで改行すると良い geom_point() # データを点（point）としてデザインするためのコードを追加 Figure 2.2: 散布図。x軸は排気量、y軸は燃費を表している。 完成。基本はこれだけである。 なお、ほとんどのグラフはx軸とy軸から構成されるので、実はコードの中に一々x = dispやy = mpgと書く必要はない。また、データについても自明なので、data = mtcarsと書く必要もない。つまり、上のコードは下のように書くこともできる（これ以降、data, x, yは省略する）。 ggplot(mtcars, aes(disp, mpg)) + geom_point() Figure 2.3: コードは若干違うが、上のFigure 2.2と全く同じ散布図。 3. 変数を色（や形状）に対応づける もちろん上の図ができた時点でOKだが、これだけではどうも味気ない。では、ここで一歩進んで、もう1つ変数を加えてみよう。その変数とは、 cyl：シリンダーの個数（4, 6, or 8） である。このとき「シリンダーの個数によって、排気量と燃費の関係は違うのではないか？」ということが思いつく。 それでは、cylによって点の色を変えてみよう。以下のコードを書けばOKである。 ggplot(mtcars, aes(disp, mpg, color = cyl)) + # color = year を追加 geom_point() Figure 2.4: シリンダーの個数を点の色に対応づけた散布図。 aes()にcolor = cylを追加することで、cylを色に対応づけることができた。 しかし、このグラフは厳密には間違っている。どこが間違っているのだろうか？ 少し考えてみてほしい。 答え 図の右側の青いバー（凡例；legend）を見ると、その横にシリンダーの個数が連続変数として1刻みで描かれれている（4,5,6,7,8）。しかし、実際のデータには4,6,8という3種類の値しかない。もちろん個数は連続的なものだが、この場合は離散変数（discrete variable；質的変数、qualitative/categorical/factor variableとも言う）として扱ったほうがデータの表現として妥当だろう3。 この場合、cylをfactor()でくくると解決する。 ggplot(mtcars, aes(disp, mpg, color = factor(cyl))) + # factor(cyl)に変更 geom_point() Figure 2.5: シリンダー数を離散変数とした上で色に対応づけた散布図。 Rでは、factor(変数)とすることで、その変数を離散変数として扱うことができるようになる。その結果、凡例の表示も妥当なものとなった。 2.2 まとめ このように、ggplot2を使うと、数行のコードでそれなりに見栄えの良い図が描けるようになる。 手順をもう一度おさらいしよう。 1. x軸とy軸にどの変数を対応づけたいかを考える 何（y軸）を何（x軸）に応じてプロットしたいかを考えるのが可視化の第一歩である。 これが思いつけば可視化は大体うまくいったようなものである。 2. どのようなデザインでプロットしたいかを指示する データの性質（特に離散変数か連続変数か）に応じてデザインを決める。 たとえば「x軸が連続変数でy軸が連続変数なら散布図」というように決める。こういうのは大体コンセンサスが取れている4ので、以降の章でそれを学んでいってほしい。 今回は散布図しか描かなかったが、たとえば散布図の上に回帰直線を重ね書きする、というように、複数の表現を組み合わせてプロットすることも可能である。これは追々見ていくことにする。 3. 変数を色（や形状）に対応づける x軸、y軸以外に追加したい変数がある場合は、色などに対応づける。 まずは基本のプロットができるようになることを目指すので、細かい色の調整方法などは後の方で少しだけ解説する。 下に載せているのはあくまでごく一部だが、ggplot2では以下のデザイン（geom_xxxx()）を使うことが多い。 geom デザイン geom_bar() 棒グラフ geom_line() 折れ線グラフ geom_point() 散布図、点 geom_errorbar() エラーバー geom_pointrange() 点＋線 geom_histogram() ヒストグラム geom_density() 密度曲線 geom_boxplot() 箱ひげ図 geom_violin() バイオリンプロット geom_area() 面グラフ geom_smooth() 関数のフィッティング geom_text() テキスト これもまたごく一部だが、変数はx、y、colorだけでなく、以下の要素（aes()）にも対応づけることができる。 aes() 要素 x x軸 y y軸 color 枠の色 fill 塗りつぶしの色 linetype 線の形 size 線の太さ、点の大きさ shape 点の形 以降の章では、よく用いる可視化のパターンについて見ていくことにする。 ggplot2において厳密にはレイヤー（layer）などと呼んだりするが、そこら辺は入門段階ではあまり気にしなくて良い。というか、ぶっちゃけ筆者自身も厳密なことはわかっていない。↩ 変数が連続か離散かという区別は、可視化の上で結構重要なので意識しておくと良い。↩ これはヒューリスティックであり、時には例外もある。しかし、大体の場合正しい。↩ "],
["amount.html", "3 数量 3.1 棒グラフ 3.2 Clevelandのドットプロット 3.3 練習問題", " 3 数量 基本中の基本として、まずはデータの数量（数値、個数、比率、順位など）を可視化してみよう。 library(ggplot2) # 忘れずにパッケージを読み込む 3.1 棒グラフ 3.1.1 基本の棒グラフ 数量の可視化で最も代表的、かつ馴染み深いのは棒グラフ（bar graph; bar chart; bar plot）だろう。 まず、最も基本的な棒グラフを描いてみよう。使うデータは、gcookbookパッケージのpg_mean（植物の重さに関するデータセット）である。まず、gcookbookを読み込む。 library(gcookbook) データの中身は以下の通りである。 head(pg_mean) # データが3行しかないのですべて表示される ## group weight ## 1 ctrl 5.032 ## 2 trt1 4.661 ## 3 trt2 5.526 2つの変数はそれぞれ group：実験の条件（3水準） weight：植物の重さの平均値 を表している。素朴に思いつくのは、「条件をx軸に、重さをy軸に取った棒グラフ」だろう。数量を表す棒グラフは、geom_bar()をで描くことができる。 ggplot(pg_mean, aes(group, weight)) + # x軸にgroup、y軸にweight geom_bar(stat = &quot;identity&quot;) # 棒グラフ；stat = &quot;identity&quot;が必要 Figure 3.1: 棒グラフ。x軸は条件、y軸は植物の平均重量を表している。 なお、データの数値を棒グラフで描く際は、stat = &quot;identity&quot;と設定する必要がある。なぜなら、geom_bar()は、データの個数を描くのがデフォルト（stat = &quot;count&quot;という設定）になっているからである5。 気になる人は、stat = &quot;identity&quot;の部分を消してコードを実行してみよう。エラー: stat_count() must not be used with a y aesthetic.というエラーメッセージが出て、プロットできないはずである6。 3.1.2 グルーピングされた棒グラフ では、ここに変数を1つ追加してみよう。次に使うデータはgcookbookのcabbage_exp（キャベツに関するデータセット）である。 head(cabbage_exp) # 6行しかないのですべて表示される ## Cultivar Date Weight sd n se ## 1 c39 d16 3.18 0.9566144 10 0.30250803 ## 2 c39 d20 2.80 0.2788867 10 0.08819171 ## 3 c39 d21 2.74 0.9834181 10 0.31098410 ## 4 c52 d16 2.26 0.4452215 10 0.14079141 ## 5 c52 d20 3.11 0.7908505 10 0.25008887 ## 6 c52 d21 1.47 0.2110819 10 0.06674995 注目する変数は以下の3つである。 Date：キャベツの栽培期間（d16, d20, or d21） Cultivar：キャベツの品種（c39 or c52） Weight：キャベツの重量（kg） このとき、栽培期間と品種ごとにキャベツの重量を描いてみたいと思わない人はいない7。このようなときは、Dateをx、Weightをy、Cultivarをfillに対応づけて描けば良い。 ggplot(cabbage_exp, aes(Date, Weight, fill = Cultivar)) + # x軸にDate、y軸にWeight；fill = Cultivarを追加 geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) # 棒グラフ；position = &quot;dodge&quot;が必要 Figure 3.2: グルーピングされた棒グラフ。 このように、2つの変数ごとに棒グラフを描きたい（グルーピングしたい）場合は、fillに変数を追加すれば良い。fillは「塗りつぶし」を意味しており、実際Cultivarの種類に応じて棒が塗りつぶされていることがわかる8。 なお、このようなグラフを描く際は、基本的にposition = &quot;dodge&quot;と指定する必要がある。なぜなら、geom_bar()はデフォルトがposition = &quot;stack&quot;であり、そのままだと積み上げ棒グラフになってしまうからである。ちなみに、position = &quot;fill&quot;と指定すれば、全体を100%にした積み上げ棒グラフを描くことができる。積み上げ棒グラフは割合や比率を表すのによく使われるグラフである。 3.1.3 個数を表す棒グラフ では、データの数値ではなく、データの個数（カウントデータ）はどのようにプロットすればよいだろうか？ 次は、ggplot2のdiamonds（ダイアモンドに関するデータセット）を使ってみよう。 head(diamonds) # 先頭6行 ## # A tibble: 6 x 10 ## carat cut color clarity depth table price x y z ## &lt;dbl&gt; &lt;ord&gt; &lt;ord&gt; &lt;ord&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.23 Ideal E SI2 61.5 55 326 3.95 3.98 2.43 ## 2 0.21 Premium E SI1 59.8 61 326 3.89 3.84 2.31 ## 3 0.23 Good E VS1 56.9 65 327 4.05 4.07 2.31 ## 4 0.290 Premium I VS2 62.4 58 334 4.2 4.23 2.63 ## 5 0.31 Good J SI2 63.3 58 335 4.34 4.35 2.75 ## 6 0.24 Very Good J VVS2 62.8 57 336 3.94 3.96 2.48 ここではcutという変数に着目してみよう。 cut：ダイアモンドのカットの質（Fair, Good, Very Good, Premium, or Ideal） ダイアモンドの個数をカットに応じてプロットしてみよう。なお、geom_bar()はデータの個数を自動的に数えてくれるので、yに変数を対応づける必要はない。 ggplot(diamonds, aes(cut)) + # x軸にcut；yには何も対応づける必要なし geom_bar() # 棒グラフ；今回はデータの値ではなく個数を描くので、stat = &quot;identity&quot;は不要 Figure 3.3: カットごとのダイアモンドの個数。 無事に個数をプロットすることができた。 3.2 Clevelandのドットプロット 数量の可視化に向いているのは棒グラフだけではない。というよりもむしろ、棒グラフが可視化に向かない場合もある。たとえば、gcookbookのtophitters2001（2001年MLBの上位144打手のデータセット）を使ってそれを見てみよう。 head(tophitters2001) ## id first last name year stint team lg g ab r ## 1 walkela01 Larry Walker Larry Walker 2001 1 COL NL 142 497 107 ## 2 suzukic01 Ichiro Suzuki Ichiro Suzuki 2001 1 SEA AL 157 692 127 ## 3 giambja01 Jason Giambi Jason Giambi 2001 1 OAK AL 154 520 109 ## 4 alomaro01 Roberto Alomar Roberto Alomar 2001 1 CLE AL 157 575 113 ## 5 heltoto01 Todd Helton Todd Helton 2001 1 COL NL 159 587 132 ## 6 aloumo01 Moises Alou Moises Alou 2001 1 HOU NL 136 513 79 ## h 2b 3b hr rbi sb cs bb so ibb hbp sh sf gidp avg ## 1 174 35 3 38 123 14 5 82 103 6 14 0 8 9 0.3501 ## 2 242 34 8 8 69 56 14 30 53 10 8 4 4 3 0.3497 ## 3 178 47 2 38 120 2 0 129 83 24 13 0 9 17 0.3423 ## 4 193 34 12 20 100 30 6 80 71 5 4 9 9 9 0.3357 ## 5 197 54 2 49 146 7 5 98 104 15 5 1 5 14 0.3356 ## 6 170 31 1 27 108 5 1 57 57 14 3 0 8 18 0.3314 変数がたくさんあるが、とりあえず name：打手の名前 avg：打率 に注目してみよう。なお、データが144行と少し多いので、わかりやすさのため先頭の20名のデータだけを使うことにする。20名のデータはtop20hittersに代入する。 top20hitters = tophitters2001[1:20,] # 先頭20行を抽出してtop20hittersに代入 それでは、このtop20hittersを使って、まずは打手ごとの打率を素直に棒グラフで描いてみよう。 ggplot(top20hitters, aes(name, avg)) + # x軸にname、y軸にavg geom_bar(stat = &quot;identity&quot;) # 棒グラフ Figure 3.4: 2001年MLBのトップ20の打率。 これを見てどのように思うだろうか？ おそらく「あまり美しくない」と感じる人が多いだろう。では、どこが問題なのか。大きく2つの問題点が挙げられるだろう。 問題1. 選手ごとの打率の違いが明確に見えない 棒グラフはy = 0から始まるという性質がある9。しかし、今回のデータの値（打率）は基本的に0.3前後なので、y = 0をグラフに含めるとデータの特徴が見えづらくなってしまう。このような場合、棒グラフは可視化に向いていない。 問題2. 打率の高低によって選手が並び替えられていない（ソートされていない） これは棒グラフ自体の問題ではないが、可視化において重要なポイントである。これも直す必要があるだろう。 これらの問題に対する解決策の1つとして、Clevelandのドットプロット（Cleveland dot plot）というものがある。ドットプロットというくらいなので、散布図のようにデータをドットで表現する手法である。描き方を順に見ていこう。 ggplot(top20hitters, aes(avg, reorder(name, avg))) + # x軸とy軸を交換、reorder()関数を使う geom_point() # ドットで描く；stat = &quot;identity&quot;は不要 Figure 3.5: Clevelandのドットプロット（2001年MLBトップ20の打率）。 ggplot(top20hitter, aes(avg, reorder(name, avg))) 打率をx軸、選手名をy軸にする。こうすることで、選手名が重ならずに済む。 reorder(name, avg)により、選手名を打率でソートしている。reorder(a, b)はaをbの値で（昇順に）ソートする関数である。reorder()は、変数の順序情報を強調する際に使うと効果的である。 geom_point() データをドットで表現するための関数。 ちなみに、geom_point()ではstat = &quot;identity&quot;がデフォルトなので、geom_bar()とは異なり、statの中身を明示的に指定する必要がない。 これがClevelandのドットプロット10である。改めてFigure 3.4とFigure 3.5を見比べると、明らかにグラフの見栄えが改善していることがわかる。 3.3 練習問題 cabbage_expのデータを使い、x軸にCultivar、y軸にWeight、Dateで色分けした棒グラフを描いてみよう。 diamondsのデータを使い、clarity（輝きの等級）ごとにダイアモンドの個数をプロットしてみよう。 gcookbookのuspopchangeのデータ構造を確認しよう（?uspopchange と head(uspopchange)）。その上で、この章で学んだテクニックを使い、州ごとに人口がどれくらい増減したかをプロットしてみよう。また、どのようなデザインでプロットするのが最も妥当かつ見栄えが良いかを考えてみよう。 ここら辺のことはいずれわかるようになるので、今はそういうものだと飲み込んでほしい。いずれ勝手に理解できているはず（たぶん）。↩ 本資料のコードを修正した上で実行してもPCが壊れたりすることはないので、「ここをこうしたらどうなるだろうか？」と積極的にいじってみることを推奨する。↩ 異論は認めない。↩ 「色なのだから、colorに変数を指定するのでは？」と思った人がいるかもしれない。実際、geom_bar()でcolorに変数を指定すると、棒の枠線の色が変わる。しかし、棒グラフの枠に色をつけてもごちゃごちゃするだけなので、基本的には変数を指定する必要はない。↩ 逆に、y = 0から始まっていない棒グラフを見た場合、少し疑ってかかったほうが良い。このような棒グラフは結構巷にあふれている。↩ 類似のグラフとしてロリポッププロット（lollipop plot; lollipop chart）というものもある。https://python-graph-gallery.com/lollipop-plot/↩ "],
["distribution.html", "4 分布 4.1 ヒストグラム 4.2 密度プロット 4.3 箱ひげ図 4.4 バイオリンプロット 4.5 ストリッププロット 4.6 練習問題", " 4 分布 Chapter 1の「アンスコムの例」で見たように、データの要約統計量（summary statistics；記述統計量、descriptive statisticsとも言う）だけに注目して、分布（distribution）を確認しないと痛い目にあうことがある。 実験や調査でデータを集めたら、要約統計量を計算するだけでなく、まずデータの分布を確認・報告することを心がけよう。 library(ggplot2) # 忘れずにパッケージを読み込む 4.1 ヒストグラム 4.1.1 基本のヒストグラム 分布を表すグラフの中で最も代表的なのはヒストグラム（histogram）だろう。ヒストグラムは複数の縦棒から構成されるグラフで、棒の幅（x軸）は変数の値、棒の高さ（y軸）はデータの個数を表している。 早速具体例を見てみよう。Chapter 1と同様に、ここでもgcookbookのtophitters2001（2001年MLBにおける144名の打手データ）を使うことにする。gcookbookを読み込み、改めてデータ構造を再確認しよう。 library(gcookbook) head(tophitters2001) # データの先頭6行を再確認 ## id first last name year stint team lg g ab r ## 1 walkela01 Larry Walker Larry Walker 2001 1 COL NL 142 497 107 ## 2 suzukic01 Ichiro Suzuki Ichiro Suzuki 2001 1 SEA AL 157 692 127 ## 3 giambja01 Jason Giambi Jason Giambi 2001 1 OAK AL 154 520 109 ## 4 alomaro01 Roberto Alomar Roberto Alomar 2001 1 CLE AL 157 575 113 ## 5 heltoto01 Todd Helton Todd Helton 2001 1 COL NL 159 587 132 ## 6 aloumo01 Moises Alou Moises Alou 2001 1 HOU NL 136 513 79 ## h 2b 3b hr rbi sb cs bb so ibb hbp sh sf gidp avg ## 1 174 35 3 38 123 14 5 82 103 6 14 0 8 9 0.3501 ## 2 242 34 8 8 69 56 14 30 53 10 8 4 4 3 0.3497 ## 3 178 47 2 38 120 2 0 129 83 24 13 0 9 17 0.3423 ## 4 193 34 12 20 100 30 6 80 71 5 4 9 9 9 0.3357 ## 5 197 54 2 49 146 7 5 98 104 15 5 1 5 14 0.3356 ## 6 170 31 1 27 108 5 1 57 57 14 3 0 8 18 0.3314 では、144名の打手の打率（avg）の分布を可視化してみよう。ヒストグラムはx軸に（連続）変数の値を取るグラフなので、以下のようにコードを書けば良い。 ggplot(tophitters2001, aes(avg)) + # x軸にavg；データの個数は自動的にカウントされるので、yは指定する必要なし geom_histogram() # ヒストグラムを描く Figure 4.1: 2001年MLBにおける144名の打率の分布。 グラフを見ると、大体0.28前後が中央値（median）あるいは最頻値（mode）になっていることがわかる。 なお、ビン（bin：ヒストグラムの1本1本の棒）の幅を調整することで、分布の印象が大幅に変わるということに注意してほしい。実際、上のグラフを描いた際に、 ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. というメッセージが出たかと思う。これはまさにそのことを注意喚起するメッセージである。 データ分析の際は、ビンの幅をいくつか試した上で、最も妥当そうな値を使うようにすると良い。参考に、ビンの幅をそれぞれ0.001、0.01、0.1にした場合の図を下に載せておく。 ggplot(tophitters2001, aes(avg)) + geom_histogram(binwidth = 0.001) # binwidth = ...でビンの幅を設定 Figure 4.2: ビンが細すぎるヒストグラム。 ggplot(tophitters2001, aes(avg)) + geom_histogram(binwidth = 0.01) # binwidth = ...でビンの幅を設定 Figure 4.3: ビンが妥当なサイズのヒストグラム。 ggplot(tophitters2001, aes(avg)) + geom_histogram(binwidth = 0.1) # binwidth = ...でビンの幅を設定 Figure 4.4: ビンが太すぎるヒストグラム。 4.1.2 グルーピングされたヒストグラム たとえば、実験や調査をおこなった際、変数の分布をある集団ごとに見比べたい（グルーピングしたい）ということがあるかと思う。たとえば、「○○の尺度得点の分布は男女間で異なるのでは？」とか、「実験群と統制群とで○○の分布に違いがあるのでは？」などである。 引き続きtophitters2001を使って、その具体例を見てみよう。ここでは、リーグごとの打率の分布を見比べることにする。 lg：打手の所属リーグ（AL or NL；それぞれア・リーグとナ・リーグ） このようなときは、fillにグルーピングしたい変数（lg）を指定すれば良い。 ggplot(tophitters2001, aes(avg, fill = lg)) + # x軸にavg；fillに変数を指定することでグルーピングできる geom_histogram(position = &quot;identity&quot;) # position = &quot;identity&quot;としないといけない Figure 4.5: リーグごとの打率のヒストグラム。 なお、ここではposition = &quot;identity&quot;と設定しなくてはならない。なぜなら、geom_histogram()はposition = &quot;stack&quot;がデフォルト設定であり、そのままだと積み上げ棒グラフのようになってしまうからである。気になる人は、position = &quot;identity&quot;の部分を消した上で、もう一度グラフを描いてみよう。 また、基本的には上のヒストグラムでも問題ないが、ア・リーグのデータがナ・リーグの後ろに隠れてしまっているのが若干気になる。このようなときは、alphaに0〜1の値を指定すると、ヒストグラムが半透明になり、上の問題を解決できる。 ggplot(tophitters2001, aes(avg, fill = lg)) + geom_histogram(position = &quot;identity&quot;, alpha = 0.7) # 0だと完全に透明、1だと完全に不透明 Figure 4.6: Figure 4.5を半透明にしたもの。 無事ア・リーグのデータが見えるようになった。 4.2 密度プロット ヒストグラムと似たようなグラフに、密度プロット（density plot）がある。密度プロットとは、ヒストグラムのようにローデータ（raw data）をそのままプロットするのではなく、カーネル密度推定（kernel-density estimation）というテクニックで密度分布を推定した上で可視化する手法である。グラフが手書きの時代だった頃からヒストグラムがあるのに対し、密度プロットは計算機の発達によって開発された比較的新しいグラフである。 描き方は簡単で、上でgeom_histogram()としていたところをgeom_density()に差し替えるだけで良い。 ggplot(tophitters2001, aes(avg, fill = lg)) + # x軸にavg；fillに変数を指定することでグルーピングできる geom_density(alpha = 0.7) # デフォルトがposition = &quot;identity&quot;なので、geom_histogram(position = &quot;identity&quot;)のように明示的に指定する必要がない Figure 4.7: リーグごとの打率の密度プロット。 y軸は推定された密度を表している（5人とか10人といった人数を表しているわけではない）。この密度は、塗りつぶされた面積の総和が1になるように算出されているだけなので、値そのものにはあまり意味がないことに注意してほしい。 また、密度プロットもヒストグラムと同様に、描き方次第ではデータの性質を捉えきれないという欠点がある。geom_histogram()ではbinwidthを調整する必要があったが、geom_density()ではadjustという引数（カーネル密度推定に用いられるパラメタ）を調整する必要がある。先程と同様に、adjustの値をそれぞれ0.25, 1, 4にしたグラフを下に載せておく。 ggplot(tophitters2001, aes(avg, fill = lg)) + geom_density(alpha = 0.7, adjust = 0.25) # adjust = ...で平滑化の強度を調整 Figure 4.8: 平滑化が弱すぎる密度プロット。データの全体的な特徴が見えにくくなってしまっている。 ggplot(tophitters2001, aes(avg, fill = lg)) + geom_density(alpha = 0.7, adjust = 1) # adjust = ...で平滑化の強度を調整 Figure 4.9: 妥当な平滑化の密度プロット（デフォルトの設定）。 ggplot(tophitters2001, aes(avg, fill = lg)) + geom_density(alpha = 0.7, adjust = 4) # adjust = ...で平滑化の強度を調整 Figure 4.10: 平滑化が強すぎる密度プロット。データを平滑化しすぎており、分布の違いが見えなくなってしまっている。 ところで、Chapter 2でも少し述べたように、ggplot2では複数のプロットを重ね合わせることができる。たとえば、ヒストグラムと密度プロットは以下のように重ね合わせることができる。 ggplot(tophitters2001, aes(avg, y = ..density..)) + # y = ..density..とする必要あり geom_histogram(binwidth = 0.01) + # まずヒストグラムを描く geom_density(alpha = 0.7) # その上に密度プロットを描く Figure 4.11: ヒストグラムと密度プロットを重ねたグラフ。 なお、ここではy = ..density..をコードに追加する必要がある。なぜなら、geom_density()が密度をy軸に取るのに対し、geom_histogram()はデフォルトでデータの個数をy軸に取ってしまうからである。2つのプロットのy軸の単位を揃えるために、ここでは「データの密度（..density..）をy軸に取ってください」と明示的に指定しなければならない。 4.3 箱ひげ図 ヒストグラムや密度プロットとは異なり、データの要約統計量を示しつつ、同時に分布を表せるようなグラフも存在する。その代表例は箱ひげ図（box plot; box-and-whisker plot）だろう。 ここではRにデフォルトで搭載されているPlantGrowth（植物の重さに関する実験のデータセット）を使うことにする。 head(PlantGrowth) # 先頭6行を確認 ## weight group ## 1 4.17 ctrl ## 2 5.58 ctrl ## 3 5.18 ctrl ## 4 6.11 ctrl ## 5 4.50 ctrl ## 6 4.61 ctrl このデータには2つの変数があり、それぞれ group：実験の条件（ctrl, trt1, or trt2） weight：植物の重さ を表している。 さて、3つの条件ごとに植物の重さの分布を可視化したい。もちろんヒストグラムや密度プロットでもよいが、ここでは箱ひげ図を使ってみよう。以下のコードで箱ひげ図を描くことができる。なお、箱ひげ図に色をつけるにはfillに変数を指定すれば良い。 ggplot(PlantGrowth, aes(group, weight, fill = group)) + # x軸にgroup、y軸にweight；fillで色の塗りつぶし geom_boxplot() # 箱ひげ図を描くためのコード Figure 4.12: 箱ひげ図。x軸は条件、y軸は植物の重さを表している。 何やら謎の図形が現れたが、まさにこれが箱ひげ図である。図形のそれぞれのパーツは以下のものを表している11。 四角（箱）：四分位範囲（interquartile range, IQR）。25パーセンタイルから75パーセンタイルのこと 縦線（ひげ）：四角の上端／下端からIQR × 1.5の範囲 太線：中央値。50パーセンタイル（percentile）とも言う 点：外れ値（outlier；IQR × 1.5より外側の値） 英語版Wikipedia “Interquartile range”（https://en.wikipedia.org/wiki/Interquartile_range） の図が説明としてわかりやすいだろう。 ただし、箱ひげ図だけではデータの平均値を描くことができない12。平均値を追加するには、以下のコードを書けば良い。 ggplot(PlantGrowth, aes(group, weight, fill = group)) + geom_boxplot() + stat_summary(geom = &quot;point&quot;, fun.y = mean, color = &quot;white&quot;, shape = &quot;diamond&quot;, size = 3) # 各引数の意味はなんとなく解読してほしい Figure 4.13: 平均値を追加した箱ひげ図。 stat_summary()は統計量をプロットするための関数である。このグラフでは「y（weight）の平均値をサイズ3の白いひし形で描いてください」と指示している。各引数の意味はなんとなくわかると思うので、説明は割愛する。 4.4 バイオリンプロット 箱ひげ図に似たものとして、バイオリンプロット（violin plot）がある。バイオリンプロットとは、密度プロットを90°回転させ、アジの干物のように開いたグラフである。 バイオリンプロットは、geom_violin()で描くことができる。 ggplot(PlantGrowth, aes(group, weight, fill = group)) + # x軸にgroup、y軸にweight、fillで塗りつぶし geom_violin() # バイオリンプロットを描くためのコード Figure 4.14: バイオリンプロット。x軸は条件、y軸は植物の重さを表している。 このように、バイオリンプロットを使うと、分布の形状が箱ひげ図よりも直観的にわかるようになる。なお、geom_density()と同様に、geom_violin()でも、カーネル密度推定用のパラメタ（adjust）をいじることができるので、いくつか試してみてほしい。 4.5 ストリッププロット 箱ひげ図／バイオリンプロットは、ストリッププロット（strip plot）とも相性が良い。ストリッププロットとは、1つ1つのデータをそのままドットとして表現したグラフである。この説明ではイメージが湧きにくいと思うので、とりあえず下のプロットを見てほしい。 ggplot(PlantGrowth, aes(group, weight, fill = group)) + # x軸にgroup、y軸にweight、fillで塗りつぶし geom_violin() + # まずバイオリンプロット geom_boxplot(outlier.shape = NA, width = 0.2) + # その上に箱ひげ図 geom_point(position = position_jitter(width = 0.1, height = 0, seed = 1)) + # その上にストリッププロット stat_summary(geom = &quot;point&quot;, fun.y = mean, shape = &quot;diamond&quot;, color = &quot;white&quot;, size = 3) # おまけに平均値を追加 Figure 4.15: ストリッププロットを箱ひげ図とバイオリンプロットの上に重ね合わせた図。ドットはデータそのものを表している。 図中の黒いドットたちがストリッププロットである。1個1個のドットはデータそのものを表している。 コードの内容を上から順に解説する。 ggplot(PlantGrowth, aes(group, weight, fill = group)) x軸にgroup、y軸にweightを指定。groupごとに塗りつぶす。 geom_violin() バイオリンプロットを描く。 geom_boxplot(outlier.shape = NA, width = 0.2) その上に箱ひげ図を描く。 outlier.shape = NAとして外れ値を消すのがポイント。デフォルトだと、箱ひげ図の外れ値とストリッププロットのドットが混在してしまう。 widthは箱ひげ図の幅を調整する引数。1がデフォルトの大きさ。 geom_point(position = position_jitter(width = 0.1, seed = 1)) さらにストリッププロット（ドット）を描く。 position = position_jitter()はドットの位置をジッター（jitter：散らばらせる）ための関数である。これを設定しないと、ドットが縦一列に並んでしまい、データ構造が非常に見づらくなる（気になる人は、試しにposition以下を消して実行してみよう）。 widthは水平（x軸）方向の散らばり幅を調整する引数。また、seedはジッター具合を決めるための引数（乱数生成のシード）である。これを決めないと毎回ドットの位置が変わってしまうので、再現性を担保するためにも設定しておくと良い（気になる人は、試しにseed以下を消した上で何回か実行してみよう）。 この図の場合、ドットが垂直（y軸）方向にも散らばっていると、誤解を招く結果を導きかねない。そのため、height（垂直方向の散らばりの大きさ）は0にしている。 stat_summary(geom = &quot;point&quot;, fun.y = mean, shape = &quot;diamond&quot;, color = &quot;white&quot;, size = 3) おまけに平均値を描く。 データポイントがそこまで大量でない場合は、このようにプロットするのが良いだろう。 4.6 練習問題 Rにデフォルトで入っているiris（アヤメに関するデータセット13 ）を使い、SpeciesごとにSepal.Lengthのヒストグラムと密度プロットをそれぞれ描いてみよう。 SpeciesごとにSepal.Widthの箱ひげ図、バイオリンプロット、ストリッププロットを重ね書きしてみよう。 色々なスタイル・流派があるらしいが、ここでは最もよく使われるTukeyの箱ひげ図を説明している。↩ 平均値は外れ値に引っ張られるので、分布の代表値としては中央値のほうが妥当な場合が多い。箱ひげ図がデフォルトで平均値を描かないのもおそらくはそのため。↩ 様々なデータ分析においてチュートリアル的に用いられる代表的なデータセット。https://en.wikipedia.org/wiki/Iris_flower_data_set↩ "],
["association.html", "5 連続変数間の関係 5.1 基本の散布図 5.2 グルーピングされた散布図 5.3 散布図行列 5.4 オーバープロットへの対処 5.5 練習問題", " 5 連続変数間の関係 連続変数間の関係を見たいときは、散布図（scatter plot）を描くのがセオリーである。 library(ggplot2) # 忘れずにパッケージを読み込む 5.1 基本の散布図 ここでは、Rにデフォルトで入っているfaithful（オールド・フェイスフル・ガイザーに関するデータセット）を使ってみよう。ちなみに、オールド・フェイスフル・ガイザーとは、イエローストーン国立公園内にある間欠泉のことである14。 head(faithful) # 先頭6行 ## eruptions waiting ## 1 3.600 79 ## 2 1.800 54 ## 3 3.333 74 ## 4 2.283 62 ## 5 4.533 85 ## 6 2.883 55 変数はそれぞれ、 eruptions：間欠泉の噴出時間（分） waiting：次の間欠泉が噴出するまでの時間（分） を表している。散布図はドットから構成されるグラフなので、geom_point()で描くことができる。 ggplot(faithful, aes(eruptions, waiting)) + # x軸にeruptions、y軸にwaiting geom_point() # 散布図を描く（データをドットとして表示する） Figure 5.1: faithfulデータの散布図。強い正の相関が見て取れる。また、データを2つのクラスタに分けられそうなことが見て取れる。 5.2 グルーピングされた散布図 Chapter 2のチュートリアルでも見たが、複数グループの散布図を描く（グルーピングする）ことも可能である。Rにデフォルトで入っているmtcarsを使い、改めてChapter 2で描いた散布図の復習をしよう。geom_point()でグループごとに色を変えるには、colorに変数を指定すれば良い。 ggplot(mtcars, aes(wt, mpg, color = factor(cyl))) + # factor(変数)とすることで、離散変数として扱える geom_point() Figure 5.2: グルーピングされた散布図。 見やすさや色覚バリアフリーという観点に立てば、点の形も変えたほうが良いだろう15。ドットの形を変えるには、shapeに変数を指定すれば良い。 ggplot(mtcars, aes(disp, mpg, color = factor(cyl), shape = factor(cyl))) + # shape = factor(year)を追加 geom_point() Figure 5.3: Figure 5.2のドットの形を変えた散布図。 cyl（シリンダーの個数）の値に応じてデータポイントの形が変わっているのが見て取れる。 5.3 散布図行列 faithfulデータは変数が2つだけなので、散布図を1つ描けば終わりである。しかし、実際のデータには多くの変数がある。変数が増えるにつれて、確認しなければならない散布図の数は爆発的に増える。そのようなとき、1つ1つ散布図を描くのは面倒である。 しかし、そんなときに便利なものがある16。それは、GGallyパッケージのggpairs()という関数である。では早速、Rにデフォルトで入っているirisデータで試してみよう。まずはGGallyパッケージを読み込む。 library(GGally) # パッケージの読み込み あとは、ggpairs()にデータセットを突っ込むだけ。以上。 ggpairs(iris) # 散布図行列を描く Figure 5.4: ggpairs()によるirisデータの散布図行列。散布図だけでなく、変数の種類に応じて自動で箱ひげ図などもプロットされる。 なんと、これだけで多変量の散布図、箱ひげ図などを一撃で描画できてしまうのである。しかも、変数の連続／離散に応じて適切なグラフを選んでくれる親切ゆとり設計である。 ただ、これだけでは少し味気ないので、Speciesに応じて色をつけてみよう。ggplot2と同じように指定すれば良い。 ggpairs(iris, aes(color = Species, alpha = 0.7)) # ggplot2と同じように色と透明度を指定 Figure 5.5: Figure 5.4に色をつけて半透明にした図。 他にも細かい設定ができるそうだが、ここでは説明を割愛する17。 5.4 オーバープロットへの対処 最後に、オーバープロットというものへの対処法を見ていくことにする。具体例として、ggplot2に入っているmpgデータを使ってみよう。 head(mpg) # 先頭6行 ## # A tibble: 6 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… ## 3 audi a4 2 2008 4 manua… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto(… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto(… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manua… f 18 26 p comp… 注目する変数は、 displ：エンジンの排気量（リットル） hwy：燃費（マイル／ガロン） cyl：シリンダー数（4, 5, 6, or 8） の2つである。早速、xにdispl、yにhwy、colorにfactor(cyl)を指定して散布図を描いてみよう。 ggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point() Figure 5.6: デフォルトの設定で描いた散布図。 とりあえず散布図を描くことができた。一見問題は無さそうである。 では、ここでmpgのデータの行数（データポイントの数）を確認してみよう。nrow(データセット)で確認することができる。 nrow(mpg) ## [1] 234 なんと234個もあった。しかし、Figure 5.6の散布図では、データ（ドット）がせいぜい数十〜百個ぐらいにしか見えない。なぜだろうか？ なぜなら、x軸の値とy軸の値が全く同じデータポイントが複数個存在しており、それらが重なってしまっているからである。このような状態をオーバープロット（overplotting）という。 たとえば、7件法のリカート尺度によって実験参加者の特性を測り、その散布図を描くというときに、オーバープロットは間違いなく生じる。では、どのように対処すればよいのだろうか？ ここでは、Chapter 4でも扱ったジッター（jittering）というテクニックを使えば良い。 ggplot(mpg, aes(displ, hwy, color = factor(cyl))) + geom_point(position = position_jitter(width = 0.1, height = 0.4, seed = 1)) # ドットをジッターさせている Figure 5.7: ドットをジッターさせた散布図。 position = position_jitter(width = ..., height = ..., seed = ...)を指定することで、オーバープロットを回避することができた。このとき、widthやheightに大きすぎる値を入れてしまうと、データが大きく歪んでしまうので注意が必要である。 また、ここで点の形状や透明度を調節すれば、重複している箇所がより見やすくなって良いだろう。 ggplot(mpg, aes(displ, hwy, color = factor(cyl), shape = factor(cyl))) + # shapeに変数を指定 geom_point(position = position_jitter(width = 0.1, height = 0.4, seed = 1), alpha = 0.7) # alpha = 0.7を追加 Figure 5.8: Figure 5.7のドットの形状と透明度を変えたもの。 5.5 練習問題 Rにデフォルトで入っているtreesデータを使い、GirthとVolumeの散布図を描いてみよう。 gcookbookのheightweightデータの散布図行列を描いてみよう。 https://ja.wikipedia.org/wiki/オールド・フェイスフル・ガイザー↩ このように、あえて情報に冗長性を持たせることをredundant codingという。↩ データ分析で「困ったなあ」とか「こういうのあれば便利なんだけど」と思うようなことは、大体海外の偉い人が既に解決してくれているものなので、困ったときはやはり（英語で）ググルに限る。これは重要なライフハックである。↩ ぶっちゃけあまり知らない。↩ "],
["trend-data.html", "6 トレンドデータ 6.1 基本の折れ線グラフ 6.2 グルーピングされた折れ線グラフ 6.3 面グラフ 6.4 練習問題", " 6 トレンドデータ x軸が時間であったり、連続変数かつ何かしらの説明要因である場合、折れ線グラフ（line graph）を描くのがセオリーである。 library(ggplot2) # 忘れずにパッケージを読み込む 6.1 基本の折れ線グラフ まずは、gcookbookのaaplデータ（Appleの週ごとの株価データ）を可視化してみよう。 library(gcookbook) # パッケージの読み込み head(aapl) # 先頭6行 ## date adj_price ## 1 1980-12-12 0.023268 ## 2 1980-12-19 0.022863 ## 3 1980-12-26 0.028731 ## 4 1981-01-02 0.027921 ## 5 1981-01-09 0.025797 ## 6 1981-01-16 0.025089 変数はそれぞれ、 date：記録日 adj_price：株価 を表している。では、株価の時系列変化をプロットしてみよう。geom_line()で折れ線グラフを描くことができる。 ggplot(aapl, aes(date, adj_price)) + # x軸にdate、y軸にadj_price geom_line() # 折れ線グラフ Figure 6.1: Appleの株価データ。 次は、Rにデフォルトで入っているBOD（生物化学的酸素要求量に関するデータセット）を可視化してみよう。なお、生物化学的酸素要求量（biochemical oxygen demand; BOD）とは水質指標のことである18。 head(BOD) # 6行しかないのですべて表示される ## Time demand ## 1 1 8.3 ## 2 2 10.3 ## 3 3 19.0 ## 4 4 16.0 ## 5 5 15.6 ## 6 7 19.8 早速、xにTime（時間）、yにDemand（BOD）を取って折れ線グラフを描いてみよう。 ggplot(BOD, aes(Time, demand)) + # x軸にTime、y軸にdemand geom_line() + # 折れ線グラフ geom_point() # ドットは添えるだけ Figure 6.2: BODの折れ線グラフ。 なお、ここではgeom_point()を加えることで、ドットもプロットしている。BODのようにデータポイントが少ない場合、折れ線だけでなく、ドットを添えると視覚的に楽になるように思われる（個人的意見だが）。逆に、Figure 6.1のようにデータポイントが多い場合、ドットは不要である。 6.2 グルーピングされた折れ線グラフ では、例のごとく、折れ線グラフを複数のグループごとに描いてみよう。ここでは、Rにデフォルトで入っているToothGrowth（モルモットの歯に関するデータセット）を使ってみることにする。早速データを確認してみよう。 head(ToothGrowth) # 先頭6行 ## len supp dose ## 1 4.2 VC 0.5 ## 2 11.5 VC 0.5 ## 3 7.3 VC 0.5 ## 4 5.8 VC 0.5 ## 5 6.4 VC 0.5 ## 6 10.0 VC 0.5 変数はそれぞれ、 len：モルモットの歯の長さ supp：ビタミンCの与え方（VC or OJ；アスコルビン酸かオレンジジュース） dose：ビタミンCの投与量（mg／日） を表している。ここで、suppとdoseごとにlenの平均値をプロットしてみようと思うのだが、ToothGrowthには平均値のデータが入っておらず、自分で計算しなくてはならない。そこで、以下のコードを使って、平均値のデータセット（tg_mean）を新しく作ることにする。なお、今はまだ下のコードの内容を理解できなくても良い19。 library(tidyverse) # データ加工用のパッケージ群を読み込む。色々メッセージが出るだろうが気にしなくて良い。 tg_mean = ToothGrowth %&gt;% # ToothGrowthデータの group_by(supp, dose) %&gt;% # suppとdoseごとに summarise(mean = mean(len)) # lenの平均値を計算せよ tg_mean ## # A tibble: 6 x 3 ## # Groups: supp [?] ## supp dose mean ## &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 OJ 0.5 13.2 ## 2 OJ 1 22.7 ## 3 OJ 2 26.1 ## 4 VC 0.5 7.98 ## 5 VC 1 16.8 ## 6 VC 2 26.1 meanはモルモットの歯の長さ（len）の平均値を表している。 それでは、以下のコードを実行して、suppごとにdoseとmeanの関係を可視化してみよう。 ggplot(tg_mean, aes(dose, mean, group = supp)) + # x軸にdose、y軸にmean；group = suppが必要 geom_line() Figure 6.3: suppごとにグルーピングされた折れ線グラフ。 suppごとにdoseとmeanの関係をプロットすることができた。なお、geom_line()をグルーピングする際には、groupに変数を指定しなければならない（指定しないとどうなるのだろうか？ 気になる人は確認してみよう）。 ただし、このままでは見にくいので、折れ線の色（color）と線種（linetype）にも変数を指定しよう。また、geom_line()のsizeで折れ線の太さを調整することができる。 加えて、ドットも付け足しておこう。Chapter 5でも見たように、shapeに変数を指定するとドットの形を変えることができる。また、geom_point()のsizeでドットの大きさを調整することができる。 ggplot(tg_mean, aes(dose, mean, color = supp, group = supp, linetype = supp, shape = supp)) + # color、linetype、shape = suppを追加 geom_line(size = 1.5) + # sizeで太さを指定 geom_point(size = 5) # ドットは添えるだけ。sizeで大きさを指定 Figure 6.4: Figure 6.3の折れ線の色と線種をsuppごとに変え、さらにドットを付け足したグラフ。 6.3 面グラフ 時間に伴う数量の変化の大きさをグループごとに比較・強調したい際には、面グラフ（area graph; area chart）が向いている。 ここでは、gcookbookのuspopage（1900〜2002年のアメリカの人口統計）を使ってみよう。 head(uspopage) ## Year AgeGroup Thousands ## 1 1900 &lt;5 9181 ## 2 1900 5-14 16966 ## 3 1900 15-24 14951 ## 4 1900 25-34 12161 ## 5 1900 35-44 9273 ## 6 1900 45-54 6437 変数はそれぞれ、 Year：年 AgeGroup：年齢のカテゴリ Thousands：人口 を表している。面グラフはgeom_area()で描くことができる。また、グループごとに色分けするには、fillに変数を指定すれば良い。 ggplot(uspopage, aes(Year, Thousands, fill = AgeGroup)) + # x軸にYear、y軸にThousands；fill = AgeGroupと指定することで、自動で塗りつぶされる geom_area() # 面グラフ Figure 6.5: アメリカの人口の推移を表した面グラフ。 6.4 練習問題 ggplot2のeconomicsデータを使って、失業者数の推移をプロットしてみよう。 gcookbookのworldpopデータをもとに、geom_line()とgeom_point()を使い、世界人口の推移をプロットしてみよう。また、世界人口の素値ではなく常用対数をプロットするとどのようになるだろうか？（ヒント：log10(変数)で常用対数を計算することができる） https://ja.wikipedia.org/wiki/生物化学的酸素要求量↩ データハンドリングなどについては、Chapter 9で詳しく見ることにする。↩ "],
["statistics.html", "7 推測統計 7.1 エラーバー 7.2 信頼区間 7.3 回帰直線などのフィッティング 7.4 練習問題", " 7 推測統計 データの可視化では、推測統計量のプロットを含めることがしばしばである。 library(ggplot2) # 忘れずにパッケージを読み込む 7.1 エラーバー エラーバー（error bar）は誰でも馴染みがあるのではないだろうか。棒グラフとよく一緒にいるアイツのことである。エラーバーはデータの標準誤差（standard error of the mean; SEM20）を表すのに使われることが多い。 ここでは、gcookbookのcabbage_exp（キャベツに関するデータセット）を使ってエラーバーを描いてみよう。 library(gcookbook) # パッケージの読み込み head(cabbage_exp) #6行のデータなのですべて表示される ## Cultivar Date Weight sd n se ## 1 c39 d16 3.18 0.9566144 10 0.30250803 ## 2 c39 d20 2.80 0.2788867 10 0.08819171 ## 3 c39 d21 2.74 0.9834181 10 0.31098410 ## 4 c52 d16 2.26 0.4452215 10 0.14079141 ## 5 c52 d20 3.11 0.7908505 10 0.25008887 ## 6 c52 d21 1.47 0.2110819 10 0.06674995 注目する変数は、 Cultivar：キャベツの品種（c39 or c52） Date：栽培期間 Weight：キャベツの平均重量 se：キャベツの平均重量の標準誤差 である。平均値を棒グラフで、標準誤差をエラーバーで描いてみよう。コードは以下の通りである。 ggplot(cabbage_exp, aes(Date, Weight, fill = Cultivar)) + # x軸にDate、y軸にWeight、Cultivarごとに色分け geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + # グルーピングされた棒グラフの復習 geom_errorbar(aes(ymin = Weight - se, ymax = Weight + se), position = position_dodge(width = 0.9), width = 0.2) # ymin：エラーバーの下端、ymax：エラーバーの上端 Figure 7.1: エラーバー付きの棒グラフ。エラーバーは標準誤差を表している。 コードの内容を順に解説する。 ggplot(cabbage_exp, aes(Date, Weight, fill = Cultivar) x軸にDate、y軸にWeight、グルーピング（塗りつぶし）にCultivarを指定。 geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) 棒グラフ。stat = &quot;identity&quot;とする必要がある。また、Cultivarごとに位置をずらすには、position = &quot;dodge&quot;としなければならない。 忘れてしまった人は、もう一度Chapter 3を復習しよう。 geom_errorbar(aes(ymin = Weight - se, ymax = Weight + se), position = position_dodge(width = 0.9), width = 0.2) エラーバー。yminとymaxには、それぞれエラーバーの上端と下端のy座標を指定する。 position = position_dodge(width = 0.9)とすることで、エラーバーを棒グラフのように水平方向にずらすことができる。棒グラフのずらし幅が0.9なので、エラーバーのwidth（ずらし幅）も0.9にする21。 最後のwidthはエラーバーの横幅を表している。デフォルトだと、棒グラフの棒と同じ幅になる。 なお、エラーバーを描く際は、エラーバーが何を表しているのかをキャプションなどに含めなければならない。なぜなら、エラーバーは標準誤差、95%信頼区間（95% confidence interval; 95% CI）、標準偏差、ベイズ信頼区間など、様々な統計量を表現するのにも使われるからである。 7.2 信頼区間 信頼区間のプロットにもgeom_errorbar()は使えるが、折れ線グラフ（時系列データ）などではgeom_ribbon()の方が良いだろう。ここでは、gcookbookのclimate（気温の時系列データ）を使ってみよう。 head(climate) ## Source Year Anomaly1y Anomaly5y Anomaly10y Unc10y ## 1 Berkeley 1800 NA NA -0.435 0.505 ## 2 Berkeley 1801 NA NA -0.453 0.493 ## 3 Berkeley 1802 NA NA -0.460 0.486 ## 4 Berkeley 1803 NA NA -0.493 0.489 ## 5 Berkeley 1804 NA NA -0.536 0.483 ## 6 Berkeley 1805 NA NA -0.541 0.475 なお、ここではSourceが&quot;Berkeley&quot;のデータだけを抽出して可視化を行う。抽出したデータはclimに代入する。以下のコードは今は理解できなくて良い。 library(tidyverse) # データハンドリング用のパッケージ群を読み込む clim = climate %&gt;% # climateデータの filter(Source == &quot;Berkeley&quot;) # Sourceが&quot;Berkeley&quot;の行だけを抽出してください プロットするのは以下の変数である。 Year：年 Anomaly10y：1951〜1980年の平均気温と比べたときのズレ Unc10y：95%信頼区間 では、geom_ribbon()を使ってプロットしてみよう。コードの書き方はgeom_errorbar()に似ている。なお、alphaで信頼区間を半透明にしないと、グラフが真っ黒になってしまうので注意が必要である。 ggplot(clim, aes(Year, Anomaly10y)) + geom_line() + geom_ribbon(aes(ymin = Anomaly10y - Unc10y, ymax = Anomaly10y + Unc10y), alpha = 0.2) # alphaで透明度を指定 Figure 7.2: 95%信頼区間のプロット。 7.3 回帰直線などのフィッティング 散布図に回帰直線などをフィッティングさせた図を見たことがあるだろう。ggplot2でもそれが可能である。ここでは、gcookbookのheightweight（こどもの身長と体重データ）を使ってみよう。 head(heightweight) # 先頭6行 ## sex ageYear ageMonth heightIn weightLb ## 1 f 11.92 143 56.3 85.0 ## 2 f 12.92 155 62.3 105.0 ## 3 f 12.75 153 63.3 108.0 ## 4 f 13.42 161 59.0 92.0 ## 5 f 15.92 191 62.5 112.5 ## 6 f 14.25 171 62.5 112.0 まず、geom_point()で身長（heightIn）と体重（WeightLb）の散布図を描き、その上にgeom_smooth()で回帰直線を描いてみよう。なお、回帰直線を引くには、method = lmと指定する必要がある（デフォルトだとLOESS曲線22 が引かれる）。Rにおいてlmは線形モデル（linear model）を表している。 ggplot(heightweight, aes(ageYear, heightIn)) + geom_point() + # まず散布図 geom_smooth(method = lm) # それから回帰直線；method = lmと指定する必要あり Figure 7.3: 散布図の上に回帰直線を描いたグラフ。網掛けの部分は95%信頼区間を表している。 グループごとに回帰直線を引きたい場合は、fillにグルーピングの変数を指定すれば良い。 ggplot(heightweight, aes(ageYear, heightIn, fill = sex)) + # fill = sexを追加 geom_point() + geom_smooth(method = lm) Figure 7.4: こどもの性別ごとに回帰直線を描いたグラフ。網掛けの部分は95%信頼区間を表している。 7.4 練習問題 Figure 7.1で描いたcabbage_expデータの平均値と標準誤差を、今度は折れ線グラフとエラーバーで描いてみよう。このとき、エラーバーはどれくらい調整すれば良いだろうか？ Rにデフォルトで入っているfaithfulデータの散布図を描き、その上に回帰直線をプロットしてみよう。 構造方程式モデリング（structural equation modeling; SEM）のことではない。↩ ちなみに、今まで出てきたposition = &quot;dodge&quot;はposition = position_dodge()の省略版である。↩ https://en.wikipedia.org/wiki/Local_regression↩ "],
["appearance.html", "8 図の体裁 8.1 軸の反転 8.2 Small multiple 8.3 テーマ 8.4 色 8.5 軸 8.6 凡例 8.7 複数パネルのグラフ 8.8 グラフの保存 8.9 練習問題", " 8 図の体裁 ggplot2はデフォルトでも十分見栄えの良いグラフを出力してくれる。しかし、より見やすいグラフを作るために少し工夫しなければならない場面もある。また、最後にグラフの保存方法などを解説する。 library(ggplot2) # 忘れずにパッケージを読み込む 8.1 軸の反転 人間誰しも、グラフの軸を反転させたくなるときがある23。Figure 3.5 のClevelandのドットプロットのようにxとyの変数を逆にしても良いが、ggplot2の設計上それではうまくいかない場合もある。 そのようなときはcoord_flip()が使えば良い。これは文字通り、座標（coordination）と反転（flip）させるための関数である。 たとえば、Figure 3.3でdiamondsデータ（cutごとのダイアモンドの個数）をプロットしたが、これにcoord_flip()を付け足すと以下のようになる。 ggplot(diamonds, aes(cut)) + # x軸にcut；yには何も対応づける必要なし geom_bar() + # 棒グラフ；データの値ではなく個数を描くので、stat = &quot;identity&quot;は不要 coord_flip() # 軸を反転 Figure 8.1: Figure 3.3の軸を反転させたグラフ。 8.2 Small multiple プロットする変数が多く、1枚にまとめると見づらくなってしまう場合、グラフを複数個の小さなパネル（サブプロット）に分割して並べると見やすくなる。これをSmall multiple24という 。Small multipleはfacet_grid()もしくはfacet_wrap()で作ることができる。 たとえば、Chapter 5で作ったmpgの散布図（Figure 5.6）は、drvとcylという変数によって、以下のような小さなパネルに分割することができる。描き方は、facet_grid(行方向の変数~列方向の変数)である。 ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_grid(drv ~ cyl) # drvは行方向、cylは列方向 Figure 8.2: facet_grid()を使った例。パネルが行列の形で表示される。 一方、facet_wrap()を使うと、2変数（drvとcyl）が入れ子構造でプロットされるようになる。デフォルトでは縦横の枚数が同じになるが、nrowおよびncolで行と列の数を指定できる。 ggplot(mpg, aes(displ, hwy)) + geom_point() + facet_wrap(drv ~ cyl) # 入れ子構造でプロット Figure 8.3: facet_wrap()を使った例。上のFigure 8.2と見比べてみよう。 なお、facet_grid()とfacet_wrap()の両方共、1変数だけでパネルを分けることも可能である。詳しくはヘルプ（?facet_grid()または?facet_wrap()）で確認してほしい。 8.3 テーマ グラフの全体的な体裁は、theme_xxxx()で変えることができる。下の図のtheme_gray()はggplot2のデフォルトのテーマである。 ggplot(mtcars, aes(wt, mpg)) + geom_point() + theme_gray() Figure 8.4: theme_gray()を使った図（デフォルトのテーマ）。 論文用の図として作ったり、大きなディスプレイに映したりする場合は、theme_bw()またはtheme_classic()が良いだろう。 ggplot(mtcars, aes(wt, mpg)) + geom_point() + theme_bw() Figure 8.5: theme_bw()を使った図。 ggplot(mtcars, aes(wt, mpg)) + geom_point() + theme_classic() Figure 8.6: theme_classic()を使った図。 その他のテーマについては、https://ggplot2.tidyverse.org/reference/ggtheme.html を見てほしい。 8.4 色 今までのグラフで散々見てきたように、fillやcolorでグルーピングを行うと、ggplot2のデフォルトのパステルカラーが適用される。ただ、この色は変えたい場合が多いだろう。 たとえば、下のようにscale_color_manual()という関数を使うと、colorで指定した変数を自分の好きな色に変えることができる25。fillで指定した変数の色を変える場合は、scale_fill_manual()という関数を使うと良い。 ggplot(mtcars, aes(wt, mpg, color = factor(cyl))) + geom_point() + scale_color_manual(values = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)) Figure 8.7: scale_color_manual()によって色を変えたグラフ。 ggplot2には、他にも色や見た目を調整するための様々な関数がある。また、色の調整にはcolorspaceというパッケージが便利だが、本資料はあくまで最低限のレベルの可視化について解説するものなので、ここではあまり深く突っ込まないことにする26。 8.5 軸 デフォルトの設定だと、変数名がそのまま軸のラベルになってしまう。データを探索的に分析（data exploration）している最中はそれで問題ないかもしれない。しかし、内容を他の人と共有（data presentation）したい場合は、なるべくわかりやすくするため、軸名を変えなくてはならないだろう27。 グラフの軸ラベルはlabs()という関数で一括変更することができる。なお、下では具体例としてTitleやSubtitleなども指定しているが、実用上はごちゃごちゃしてしまうだけなので、基本的には指定しなくても良い。 ggplot(mtcars, aes(wt, mpg, color = factor(cyl))) + geom_point() + labs(x = &quot;Weight (1,000 Ibs)&quot;, y = &quot;Miles/(US) gallon&quot;, title = &quot;Title&quot;, subtitle = &quot;Subtitle&quot;, caption = &quot;Caption&quot;, tag = &quot;Tag&quot;) Figure 8.8: labs()を使い、軸名をデフォルトから変更したグラフ。 8.6 凡例 ここでは、凡例を「消す」方法を解説する。なぜなら、凡例がなくとも自明な場合も多いからである。下の図はFigure 4.12の凡例を消したグラフである。 ggplot(PlantGrowth, aes(group, weight, fill = group)) + # x軸にgroup、y軸にweight；fillで色の塗りつぶし geom_boxplot() + # 箱ひげ図 guides(fill = FALSE) # 凡例（ここではfill）を消すためのコード Figure 8.9: 凡例を消したグラフ。 8.7 複数パネルのグラフ 論文などを描く際、複数個のグラフを組み合わせて1枚のグラフにしたいことがある。そのときは、patchworkパッケージを使うと良い。patchworkは以下の手順でインストールする。 library(devtools) install_github(&quot;thomasp85/patchwork&quot;) # パッケージのインストール library(patchwork) # パッケージの読み込み patchworkを使うと、たとえば下のように、複数のパネルを直観的に組み合わせることができる。 # まずパネルa（panel_a）を作る panel_a = ggplot(mtcars, aes(wt, mpg, color = factor(cyl))) + geom_point() # 次にパネルb（panel_b）を作る panel_b = ggplot(mtcars, aes(wt, disp, color = factor(cyl))) + geom_point() # 2つを足し算して1枚のグラフ（panel_ab）にし、1列に並べる（ncol = 1） panel_ab = panel_a + panel_b + plot_layout(ncol = 1) + plot_annotation(tag_levels = &quot;a&quot;) # 最後にタグを付ける panel_ab Figure 8.10: 2枚のパネルを組み合わせたグラフ。 8.8 グラフの保存 論文にグラフを貼り付ける前に、当然グラフを画像ファイルとして保存しなければならない。上で作ったpanel_abを“panel_ab.pdf”として保存してみよう。グラフはggsave(&quot;保存するファイル名&quot;, plot = グラフのオブジェクト, width = 幅, height = 高さ, units = &quot;サイズの単位&quot;)で保存することができる。 ggsave(&quot;panel_ab.pdf&quot;, plot = panel_ab, width = 14, height = 14, units = &quot;cm&quot;) なお、余程のことがない限り、グラフは基本的にPDF形式で保存するのが良い28。なぜPDFが良いのかはGoogleが教えてくれるだろう。 8.9 練習問題 gcookbookのheightweightデータを使い、性別ごとにパネルを分けた上で、身長と体重の散布図を描いてみよう。また、凡例を消し、軸ラベルをわかりやすく書き直してみよう（日本語だとうまく表示されない可能性があるので、英語で良い）。余力があれば、各パネル（サブプロット）のラベルも書き直してみよう。 異論は……。↩ https://en.wikipedia.org/wiki/Small_multiple↩ なお、グラフで原色を使うのはおすすめしない。Figure 8.7から明らかなように、目がチカチカしてしまうし、背景が明るいとデータポイントが見えにくくなる場合もある。また、色覚バリアフリーという点でもNGである。↩ ここまでついてこれた人であれば、自力で検索してマスターできるだろう（たぶん）。↩ 気配りと言うほどのものでもないが、こういうことをやるかやらないかで、ゼミメンバーや聴衆が自分の話を聞く態度は変わってくるだろう（たぶん）。↩ PDF形式で保存する場合、色々面倒なことが起こるかもしれないが、そこら辺はググって解決しよう。↩ "],
["data-handling.html", "9 データハンドリング 9.1 tidyverse 9.2 抽出 9.3 追加 9.4 集約 9.5 結合 9.6 ロングフォーマット 9.7 データファイルの読み込み 9.8 ggplot2と一緒に使う", " 9 データハンドリング ここまで、ggplot2を使ったデータの可視化を見てきた。ただし、ggplot2で作図をする際、大きな前提条件がある。それは、データを行列の形で用意しなければいけないというものである。つまり、変数を列に、観測値を行に取るようなデータ構造にあらかじめ整形しなければならないということである。 たとえば、今まで使ってきたmtcars、faithfulのデータ構造を改めて見てみよう。 head(mtcars) # 先頭6行 ## mpg cyl disp hp drat wt qsec vs am gear carb ## Mazda RX4 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 ## Mazda RX4 Wag 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 ## Datsun 710 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 ## Hornet 4 Drive 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 ## Hornet Sportabout 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 ## Valiant 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 head(faithful) # 先頭6行 ## eruptions waiting ## 1 3.600 79 ## 2 1.800 54 ## 3 3.333 74 ## 4 2.283 62 ## 5 4.533 85 ## 6 2.883 55 どちらも、列に変数名、行に観測値という構造をもっている。 散布図、箱ひげ図、ヒストグラムのように、これらのデータの素値をプロットする際、データハンドリングはあまり問題にならない。しかし、実際は平均値や標準誤差のように、何かしらの統計的処理を施した値をプロットしたいこともある。また、ある1つのグループのデータだけをプロットしたいという場合もある。 可視化の際に直面する問題は、おおよそ以下の3つに大別できるだろう。 1つのグループのデータだけを抽出した上でプロットしたい（たとえば、3条件のうち統制条件だけプロットしたい、など） 素値ではなく、平均値や標準誤差などの統計量をプロットしたい 2つ以上のデータフレームを結合してプロットしたい などである。 9.1 tidyverse データハンドリングに使うパッケージ群（複数のパッケージ）はtidyverseと呼ばれており、library(tidyverse)で読み込むことができる。ちなみにggplot2もtidyverseの一部なので、自動的に読み込まれる。下のコードを実行すると色々メッセージが出るかもしれないが、気にしなくて良い。 library(tidyverse) # データハンドリング用のパッケージおよびggplot2を読み込む この章では、主にggplot2のmpg（自動車のデータ）を使い、データハンドリングを見ていくことにする。 9.2 抽出 9.2.1 データの値で絞り込み データの値によって絞り込みを行いたい時がある。たとえば、mpgであれば、manufacturerの種類でデータを絞り込みたい（データの行単位で抽出したい）ということである。実際の実験データで言えば、男性／女性のデータのみ抽出したいというような場面である。 このようなときは、filter(抽出条件)を使えば良い。 mpg %&gt;% filter(manufacturer == &quot;audi&quot;) # manufacturerが&quot;audi&quot;のものだけを抽出 ## # A tibble: 18 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## 11 audi a4 q… 2 2008 4 auto… 4 19 27 p comp… ## 12 audi a4 q… 2.8 1999 6 auto… 4 15 25 p comp… ## 13 audi a4 q… 2.8 1999 6 manu… 4 17 25 p comp… ## 14 audi a4 q… 3.1 2008 6 auto… 4 17 25 p comp… ## 15 audi a4 q… 3.1 2008 6 manu… 4 15 25 p comp… ## 16 audi a6 q… 2.8 1999 6 auto… 4 15 24 p mids… ## 17 audi a6 q… 3.1 2008 6 auto… 4 17 25 p mids… ## 18 audi a6 q… 4.2 2008 8 auto… 4 16 23 p mids… ここで、==は「等しい」ということを意味している。大体のプログラミング言語では、==が「等しい」=が「代入する」を意味するものである。 ちなみに、%&gt;%はパイプ演算子と呼ばれており、オブジェクトを次の関数の第一引数に突っ込むという操作を表している。ちょっと何を言っているのか分からないと思うが、あまり気にしなくて良い。何をやっているのか、少なくとも直観的には分かるだろう。今はそれで大丈夫である。 複数条件で絞り込むこともできる。たとえば、「manufacturerが&quot;audi&quot;」かつ「modelが&quot;a4&quot;」の行を抽出したい場合は、条件を&amp;で繋げば良い。 mpg %&gt;% filter(manufacturer == &quot;audi&quot; &amp; model == &quot;a4&quot;) ## # A tibble: 7 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manua… f 21 29 p comp… ## 3 audi a4 2 2008 4 manua… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto(… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto(… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manua… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto(… f 18 27 p comp… 「manufacturerが&quot;audi&quot;」または「modelが&quot;a4&quot;」の行を抽出したい場合は、条件を|で繋げば良い。 mpg %&gt;% filter(manufacturer == &quot;audi&quot; | model == &quot;a4&quot;) ## # A tibble: 18 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## 11 audi a4 q… 2 2008 4 auto… 4 19 27 p comp… ## 12 audi a4 q… 2.8 1999 6 auto… 4 15 25 p comp… ## 13 audi a4 q… 2.8 1999 6 manu… 4 17 25 p comp… ## 14 audi a4 q… 3.1 2008 6 auto… 4 17 25 p comp… ## 15 audi a4 q… 3.1 2008 6 manu… 4 15 25 p comp… ## 16 audi a6 q… 2.8 1999 6 auto… 4 15 24 p mids… ## 17 audi a6 q… 3.1 2008 6 auto… 4 17 25 p mids… ## 18 audi a6 q… 4.2 2008 8 auto… 4 16 23 p mids… 「manufacturerが&quot;audi&quot;」でもなく「modelが&quot;a4&quot;」でもない行を抽出したい場合は、条件を!()で囲めば良い。!()は論理値を反転させる演算子である29。 mpg %&gt;% filter(!(manufacturer == &quot;audi&quot; | model == &quot;a4&quot;)) ## # A tibble: 216 x 11 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 chevrolet c150… 5.3 2008 8 auto… r 14 20 r suv ## 2 chevrolet c150… 5.3 2008 8 auto… r 11 15 e suv ## 3 chevrolet c150… 5.3 2008 8 auto… r 14 20 r suv ## 4 chevrolet c150… 5.7 1999 8 auto… r 13 17 r suv ## 5 chevrolet c150… 6 2008 8 auto… r 12 17 r suv ## 6 chevrolet corv… 5.7 1999 8 manu… r 16 26 p 2sea… ## 7 chevrolet corv… 5.7 1999 8 auto… r 15 23 p 2sea… ## 8 chevrolet corv… 6.2 2008 8 manu… r 16 26 p 2sea… ## 9 chevrolet corv… 6.2 2008 8 auto… r 15 25 p 2sea… ## 10 chevrolet corv… 7 2008 8 manu… r 15 24 p 2sea… ## # … with 206 more rows 9.2.2 データの列で絞り込み では、列方向で抽出するにはどうすれば良いのだろうか？ たとえば、mpgで言えば、manufacturerとmodelとtransとdrvの列を抽出したいというような状況である。 このようなときは、select(抽出したい列名)を使えば良い。抽出したい列名は、1つだけに限らず、何個書いても問題ない。 mpg %&gt;% select(manufacturer, model, trans, drv) # 4つの列を抽出 ## # A tibble: 234 x 4 ## manufacturer model trans drv ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 auto(l5) f ## 2 audi a4 manual(m5) f ## 3 audi a4 manual(m6) f ## 4 audi a4 auto(av) f ## 5 audi a4 auto(l5) f ## 6 audi a4 manual(m5) f ## 7 audi a4 auto(av) f ## 8 audi a4 quattro manual(m5) 4 ## 9 audi a4 quattro auto(l5) 4 ## 10 audi a4 quattro manual(m6) 4 ## # … with 224 more rows select()では、「A列からG列まで」というような抽出も可能である。 mpg %&gt;% select(manufacturer:drv) # manufacturerからdrvまでの7列を抽出 ## # A tibble: 234 x 7 ## manufacturer model displ year cyl trans drv ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto(l5) f ## 2 audi a4 1.8 1999 4 manual(m5) f ## 3 audi a4 2 2008 4 manual(m6) f ## 4 audi a4 2 2008 4 auto(av) f ## 5 audi a4 2.8 1999 6 auto(l5) f ## 6 audi a4 2.8 1999 6 manual(m5) f ## 7 audi a4 3.1 2008 6 auto(av) f ## 8 audi a4 quattro 1.8 1999 4 manual(m5) 4 ## 9 audi a4 quattro 1.8 1999 4 auto(l5) 4 ## 10 audi a4 quattro 2 2008 4 manual(m6) 4 ## # … with 224 more rows 指定した列を除外することもできるselect(-列名)とすれば良い。 mpg %&gt;% select(-manufacturer) # manufacturerを除外 ## # A tibble: 234 x 10 ## model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 a4 1.8 1999 4 auto(l5) f 18 29 p compact ## 2 a4 1.8 1999 4 manual(m5) f 21 29 p compact ## 3 a4 2 2008 4 manual(m6) f 20 31 p compact ## 4 a4 2 2008 4 auto(av) f 21 30 p compact ## 5 a4 2.8 1999 6 auto(l5) f 16 26 p compact ## 6 a4 2.8 1999 6 manual(m5) f 18 26 p compact ## 7 a4 3.1 2008 6 auto(av) f 18 27 p compact ## 8 a4 quattro 1.8 1999 4 manual(m5) 4 18 26 p compact ## 9 a4 quattro 1.8 1999 4 auto(l5) 4 16 25 p compact ## 10 a4 quattro 2 2008 4 manual(m6) 4 20 28 p compact ## # … with 224 more rows 9.3 追加 9.3.1 新しい列を追加 データフレームに新しい列を作るには、mutate(新しく作る列名 = 値)を使えば良い。 mpg %&gt;% mutate(one = 1) # 最後尾にoneという列を追加した ## # A tibble: 234 x 12 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows, and 1 more variable: one &lt;dbl&gt; 上の例ではoneという列を作り、すべての行を1で埋めたが、これはあまり実践的ではない。 mutate()が力を発揮するのは、特にif_else()という関数と組み合わせたときである。たとえば、displ（排気量）の値が3未満ならgood、3以上ならbadという列（engine）を作りたい場合、以下のように書けば良い。 mpg %&gt;% mutate(engine = if_else(displ &lt; 3, &quot;good&quot;, &quot;bad&quot;)) ## # A tibble: 234 x 12 ## manufacturer model displ year cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows, and 1 more variable: engine &lt;chr&gt; 9.3.2 列名を変更 新しい列を作りたいわけではないが、列名を変えたい場合がある。このようなときは、rename(新しい列名 = 古い列名)を使えば良い。 mpg %&gt;% rename(nen = year) # yearをnenに変更 ## # A tibble: 234 x 11 ## manufacturer model displ nen cyl trans drv cty hwy fl class ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 audi a4 1.8 1999 4 auto… f 18 29 p comp… ## 2 audi a4 1.8 1999 4 manu… f 21 29 p comp… ## 3 audi a4 2 2008 4 manu… f 20 31 p comp… ## 4 audi a4 2 2008 4 auto… f 21 30 p comp… ## 5 audi a4 2.8 1999 6 auto… f 16 26 p comp… ## 6 audi a4 2.8 1999 6 manu… f 18 26 p comp… ## 7 audi a4 3.1 2008 6 auto… f 18 27 p comp… ## 8 audi a4 q… 1.8 1999 4 manu… 4 18 26 p comp… ## 9 audi a4 q… 1.8 1999 4 auto… 4 16 25 p comp… ## 10 audi a4 q… 2 2008 4 manu… 4 20 28 p comp… ## # … with 224 more rows 9.4 集約 統計量の算出に使えるのは、group_by()とsummarise()である。 まずはsummarise()を見てみよう。書き方はsummarise(新しい列名 = 関数)である。同時に複数の関数を使うこともできる。たとえば、displの平均値、標準偏差、最小値、最大値を計算したい場合、以下のように書けば良い。 mpg %&gt;% summarise(mean_displ = mean(displ), sd_displ = sd(displ), min_displ = min(displ), max_displ = max(displ)) ## # A tibble: 1 x 4 ## mean_displ sd_displ min_displ max_displ ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 3.47 1.29 1.6 7 このように、summarise()を使うと、データ全体の統計量を計算することができる。 しかし、実際の場面で全体の統計量を計算することは少なく、むしろグループごとの統計量を計算したいという場面のほうが圧倒的に多いだろう。 このようなときは、group_by(グルーピングの変数)を使うことができる。たとえば、yearごとにsummarise()を実行するには、以下のように書けば良い。 mpg %&gt;% group_by(year) %&gt;% summarise(mean_displ = mean(displ), sd_displ = sd(displ), min_displ = min(displ), max_displ = max(displ)) ## # A tibble: 2 x 5 ## year mean_displ sd_displ min_displ max_displ ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1999 3.28 1.26 1.6 6.5 ## 2 2008 3.66 1.30 1.8 7 製造年（1999年と2008年）ごとに統計量を計算することができた。 9.5 結合 ここでは、mpgではなく、架空のデータセットを作ってみよう。たとえば、以下のような状況を考えてみてほしい。 たかし君とはなこさんは、以前見たテレビドラマを思い出して「足袋を履いたときと、裸足のときとで、どっちが走るのが早くなるだろうか？」と疑問に思いました。そこで2人は、5日間のうち3日は足袋を履いて、2日は裸足で自宅から学校まで走り、到着までの所要時間を測りました。 2人の毎日の所要時間データはcommuteというデータフレームとして保存しよう。 commute = data.frame( &quot;name&quot; = c(&quot;takashi&quot;,&quot;takashi&quot;,&quot;takashi&quot;,&quot;takashi&quot;,&quot;takashi&quot;,&quot;hanako&quot;,&quot;hanako&quot;,&quot;hanako&quot;,&quot;hanako&quot;,&quot;hanako&quot;), &quot;day&quot; = c(1,2,3,4,5,1,2,3,4,5), &quot;time&quot; = c(10,13,12,11,14,9,15,14,10,16) ) commute ## name day time ## 1 takashi 1 10 ## 2 takashi 2 13 ## 3 takashi 3 12 ## 4 takashi 4 11 ## 5 takashi 5 14 ## 6 hanako 1 9 ## 7 hanako 2 15 ## 8 hanako 3 14 ## 9 hanako 4 10 ## 10 hanako 5 16 一方、足袋だったか裸足だったかは、shoesというデータフレームとして保存しよう。 shoes = data.frame( &quot;day&quot; = c(1,2,3,4,5), &quot;shoes&quot; = c(&quot;tabi&quot;,&quot;tabi&quot;,&quot;bare&quot;,&quot;tabi&quot;,&quot;bare&quot;) ) shoes ## day shoes ## 1 1 tabi ## 2 2 tabi ## 3 3 bare ## 4 4 tabi ## 5 5 bare このようなとき、所要時間のデータと毎日の靴のデータを関係づけて可視化したいものである。しかし、別々のデータフレームとして保存されているので、今のままでは可視化できない。 このようなときは、inner_join()という関数を使えば良い。書き方は、inner_join(結合するデータ, by = &quot;共通の列名&quot;)である。今回は、dayという変数が共通なので、以下のように書けば良い。 commute %&gt;% inner_join(shoes, by = &quot;day&quot;) ## name day time shoes ## 1 takashi 1 10 tabi ## 2 takashi 2 13 tabi ## 3 takashi 3 12 bare ## 4 takashi 4 11 tabi ## 5 takashi 5 14 bare ## 6 hanako 1 9 tabi ## 7 hanako 2 15 tabi ## 8 hanako 3 14 bare ## 9 hanako 4 10 tabi ## 10 hanako 5 16 bare 無事2つのデータを結合することができた。 しかし、いつも共通の列名があるわけではない。たとえば、shoesが以下のようになっていたとしよう。 shoes = data.frame( &quot;hinichi&quot; = c(1,2,3,4,5), # &quot;day&quot;ではなく、&quot;hinichi&quot;という列名 &quot;shoes&quot; = c(&quot;tabi&quot;,&quot;tabi&quot;,&quot;bare&quot;,&quot;tabi&quot;,&quot;bare&quot;) ) shoes ## hinichi shoes ## 1 1 tabi ## 2 2 tabi ## 3 3 bare ## 4 4 tabi ## 5 5 bare このようなときは、以下のように書けば良い。 commute %&gt;% inner_join(shoes, by = c(&quot;day&quot; = &quot;hinichi&quot;)) # dayとhinichiを対応づけている ## name day time shoes ## 1 takashi 1 10 tabi ## 2 takashi 2 13 tabi ## 3 takashi 3 12 bare ## 4 takashi 4 11 tabi ## 5 takashi 5 14 bare ## 6 hanako 1 9 tabi ## 7 hanako 2 15 tabi ## 8 hanako 3 14 bare ## 9 hanako 4 10 tabi ## 10 hanako 5 16 bare この他にもleft_join()、right_join()などの関数がある。詳しくは、https://dplyr.tidyverse.org/reference/join.html を見てほしい。 9.6 ロングフォーマット 以下の架空のデータフレーム（X, Y, Zという3つの株価の増減比の時系列データ）があるとしよう。 set.seed(1) stocks = data.frame( time = as.Date(&#39;2009-01-01&#39;) + 0:9, X = rnorm(10, 0, 1), Y = rnorm(10, 0, 2), Z = rnorm(10, 0, 4) ) stocks ## time X Y Z ## 1 2009-01-01 -0.6264538 3.02356234 3.6759095 ## 2 2009-01-02 0.1836433 0.77968647 3.1285452 ## 3 2009-01-03 -0.8356286 -1.24248116 0.2982599 ## 4 2009-01-04 1.5952808 -4.42939977 -7.9574068 ## 5 2009-01-05 0.3295078 2.24986184 2.4793030 ## 6 2009-01-06 -0.8204684 -0.08986722 -0.2245150 ## 7 2009-01-07 0.4874291 -0.03238053 -0.6231820 ## 8 2009-01-08 0.7383247 1.88767242 -5.8830095 ## 9 2009-01-09 0.5757814 1.64244239 -1.9126002 ## 10 2009-01-10 -0.3053884 1.18780264 1.6717662 このとき、3つの株価の時系列変化をプロットしてみたいが、このままではうまくいかない。なぜなら、データがロングフォーマット（列に変数名、行にデータ）という形式になっていないからである。このようなデータをワイドフォーマットと言う。 データをロングフォーマットに変えるには、gather()を使えば良い。書き方は、gather(key = &quot;新しく作るラベル&quot;, value = &quot;新しく作る数値&quot;, ロングにしたい列（複数個）)である。文章ではわかりにくいと思うので、以下のコードを見てほしい。 stocks_long = stocks %&gt;% gather(key = stock, value = price, X, Y, Z) # X:Zで指定してもOK stocks_long ## time stock price ## 1 2009-01-01 X -0.62645381 ## 2 2009-01-02 X 0.18364332 ## 3 2009-01-03 X -0.83562861 ## 4 2009-01-04 X 1.59528080 ## 5 2009-01-05 X 0.32950777 ## 6 2009-01-06 X -0.82046838 ## 7 2009-01-07 X 0.48742905 ## 8 2009-01-08 X 0.73832471 ## 9 2009-01-09 X 0.57578135 ## 10 2009-01-10 X -0.30538839 ## 11 2009-01-01 Y 3.02356234 ## 12 2009-01-02 Y 0.77968647 ## 13 2009-01-03 Y -1.24248116 ## 14 2009-01-04 Y -4.42939977 ## 15 2009-01-05 Y 2.24986184 ## 16 2009-01-06 Y -0.08986722 ## 17 2009-01-07 Y -0.03238053 ## 18 2009-01-08 Y 1.88767242 ## 19 2009-01-09 Y 1.64244239 ## 20 2009-01-10 Y 1.18780264 ## 21 2009-01-01 Z 3.67590949 ## 22 2009-01-02 Z 3.12854520 ## 23 2009-01-03 Z 0.29825993 ## 24 2009-01-04 Z -7.95740678 ## 25 2009-01-05 Z 2.47930299 ## 26 2009-01-06 Z -0.22451496 ## 27 2009-01-07 Z -0.62318203 ## 28 2009-01-08 Z -5.88300954 ## 29 2009-01-09 Z -1.91260022 ## 30 2009-01-10 Z 1.67176624 ロングフォーマットにすることができた。 元のワイドフォーマットに戻したい場合は、spread()を使えば良い。書き方はspread(key = ワイドにする列, value = ワイドにする値)である。これも文章ではわかりにくいと思うので、以下のコードを見てほしい。 stocks_long %&gt;% spread(stock, price) ## time X Y Z ## 1 2009-01-01 -0.6264538 3.02356234 3.6759095 ## 2 2009-01-02 0.1836433 0.77968647 3.1285452 ## 3 2009-01-03 -0.8356286 -1.24248116 0.2982599 ## 4 2009-01-04 1.5952808 -4.42939977 -7.9574068 ## 5 2009-01-05 0.3295078 2.24986184 2.4793030 ## 6 2009-01-06 -0.8204684 -0.08986722 -0.2245150 ## 7 2009-01-07 0.4874291 -0.03238053 -0.6231820 ## 8 2009-01-08 0.7383247 1.88767242 -5.8830095 ## 9 2009-01-09 0.5757814 1.64244239 -1.9126002 ## 10 2009-01-10 -0.3053884 1.18780264 1.6717662 ワイドフォーマットに戻すことができた。 9.7 データファイルの読み込み 実際のデータファイル（たとえばcsv、tsv、xlsxなどのスプレッドシート）は、read_csv()やread_tsv()、readxlパッケージのread_excel()で読み込むことができる。 データの読み込みについては、各人の都合があると思うので、周りの人に尋ねてみてほしい30。 9.8 ggplot2と一緒に使う パイプ演算子（%&gt;%）を使うと、以下のようにデータハンドリングと可視化をシームレスにつなげることができる。下の例では、平均値と標準誤差をグループごとに計算し、棒グラフとエラーバーを描いている。 mpg %&gt;% group_by(year) %&gt;% # yearごとに summarise(mean = mean(displ), se = sd(displ) / sqrt(n())) %&gt;% # 平均値と標準誤差を計算；n()はデータの個数を数える関数 ggplot(aes(factor(year), mean, fill = factor(year))) + # dataは「%&gt;%」で自動的に流し込まれているので、指定しなくて良い geom_bar(stat = &quot;identity&quot;) + geom_errorbar(aes(ymin = mean - se, ymax = mean + se), width = 0.2) ちなみに「manufacturerが&quot;audi&quot;ではない」を書きたいときは、manufacturer != &quot;audi&quot;とすれば良い。↩ 「言語化して説明するのが大変」とは言えない。↩ "],
["e382aae383b3e383a9e382a4e383b3e8b387e69699.html", "オンライン資料", " オンライン資料 この資料を作る上で参考になった資料を以下に載せておく。可視化やデータハンドリングについて、より詳しく知りたくなった場合は、これらの資料を参考にするとよいだろう。 Winston Chang. Cookbook for R. http://www.cookbook-r.com/Graphs/ ggplot2の様々なサンプル集。とにかく手を動かして覚えるタイプの教科書。 ちなみに日本語版の書籍が売られている。 Rグラフィックスクックブックーggplot2によるグラフ作成のレシピ集 https://www.amazon.co.jp/Rグラフィックスクックブック-―ggplot2によるグラフ作成のレシピ集-Winston-Chang/dp/4873116538 Claus O. Wilke. Fundamentals of Data Visualization. https://serialmentor.com/dataviz/ 可視化やデザインの基本について教えてくれる。 このサイト自体にコードは載っていないが、可視化において注意しなければならないことがたくさん書いてある。 筆者のGitHubページに行けばコードも見ることができる。 Hadley Wickham. Elegant Graphics for Data Analysis. https://github.com/hadley/ggplot2-book ggplot2を基本から知りたい人向け。 英語版の書籍が売られている。 ggplot2: Elegant Graphics for Data Analysis (Use R!) https://www.amazon.co.jp/ggplot2-Elegant-Graphics-Data-Analysis/dp/331924275X/ref=pd_lpo_sbs_14_t_0?_encoding=UTF8&amp;psc=1&amp;refRID=2MNMAP5V2NFH89YZG5AR Kieran Healy. Data Visualization: A Practical Introduction. https://socviz.co/index.html#preface ggplot2＋可視化の入門書。最近人気の書籍のオンライン版（※全然読んでいない）。 Fundamentals of Data Visualizationとは違い、コードも載っている。 Data Visualization: A Practical Introduction. https://www.amazon.co.jp/Data-Visualization-Introduction-Kieran-Healy/dp/0691181624 もちろん、日本語でもたくさんわかりやすい解説がある（そもそもこの資料が必要ないのでは？と思うレベルで既にたくさんある）ので、もっと知りたくなったら検索して調べてみてほしい。 "],
["e5ae9fe8a18ce792b0e5a283e383bbe38390e383bce382b8e383a7e383b3e68385e5a0b1.html", "実行環境・バージョン情報", " 実行環境・バージョン情報 sessionInfo() ## R version 3.5.2 (2018-12-20) ## Platform: x86_64-apple-darwin15.6.0 (64-bit) ## Running under: macOS Mojave 10.14.3 ## ## Matrix products: default ## BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib ## LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib ## ## locale: ## [1] ja_JP.UTF-8/ja_JP.UTF-8/ja_JP.UTF-8/C/ja_JP.UTF-8/ja_JP.UTF-8 ## ## attached base packages: ## [1] stats graphics grDevices utils datasets methods base ## ## other attached packages: ## [1] patchwork_0.0.1 GGally_1.4.0 gcookbook_2.0 ## [4] bindrcpp_0.2.2 formattable_0.2.0.1 forcats_0.3.0 ## [7] stringr_1.3.1 dplyr_0.7.8 purrr_0.3.0 ## [10] readr_1.3.1 tidyr_0.8.2 tibble_2.0.1 ## [13] ggplot2_3.1.0 tidyverse_1.2.1 ## ## loaded via a namespace (and not attached): ## [1] tidyselect_0.2.5 xfun_0.4 reshape2_1.4.3 ## [4] haven_1.1.2 lattice_0.20-38 colorspace_1.4-0 ## [7] generics_0.0.2 htmltools_0.3.6 yaml_2.2.0 ## [10] utf8_1.1.4 rlang_0.3.1 pillar_1.3.1 ## [13] glue_1.3.0 withr_2.1.2 RColorBrewer_1.1-2 ## [16] modelr_0.1.2 readxl_1.1.0 bindr_0.1.1 ## [19] plyr_1.8.4 munsell_0.5.0 gtable_0.2.0 ## [22] cellranger_1.1.0 rvest_0.3.2 htmlwidgets_1.3 ## [25] evaluate_0.12 labeling_0.3 knitr_1.21 ## [28] fansi_0.4.0 highr_0.7 broom_0.5.1 ## [31] Rcpp_1.0.0 scales_1.0.0 backports_1.1.3 ## [34] jsonlite_1.6 hms_0.4.2 digest_0.6.18 ## [37] stringi_1.2.4 bookdown_0.9 grid_3.5.2 ## [40] cli_1.0.1 tools_3.5.2 magrittr_1.5 ## [43] lazyeval_0.2.1 crayon_1.3.4 pkgconfig_2.0.2 ## [46] xml2_1.2.0 lubridate_1.7.4 reshape_0.8.7 ## [49] assertthat_0.2.0 rmarkdown_1.11 httr_1.4.0 ## [52] rstudioapi_0.9.0 R6_2.3.0 nlme_3.1-137 ## [55] compiler_3.5.2 "]
]
