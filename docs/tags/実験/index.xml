<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>実験 | Kiri Kuroda</title>
    <link>https://kirikuroda.github.io/tags/%E5%AE%9F%E9%A8%93/</link>
      <atom:link href="https://kirikuroda.github.io/tags/%E5%AE%9F%E9%A8%93/index.xml" rel="self" type="application/rss+xml" />
    <description>実験</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>ja-jp</language><copyright>© Kiri Kuroda, 2021</copyright><lastBuildDate>Wed, 16 Dec 2020 15:33:47 +0900</lastBuildDate>
    <image>
      <url>https://kirikuroda.github.io/images/icon_hu9d8d1890cc5dd99366df3be946520ca2_21755_512x512_fill_lanczos_center_2.png</url>
      <title>実験</title>
      <link>https://kirikuroda.github.io/tags/%E5%AE%9F%E9%A8%93/</link>
    </image>
    
    <item>
      <title>jsPsych &#43; Firebaseでやらかした話</title>
      <link>https://kirikuroda.github.io/post/2020/12/16/jspsych-firebase/</link>
      <pubDate>Wed, 16 Dec 2020 15:33:47 +0900</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/12/16/jspsych-firebase/</guid>
      <description>&lt;h1 id=&#34;この記事のサマリー&#34;&gt;この記事のサマリー&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jsPsychとFirebaseでウェブ実験を実施した&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;私の浅知恵のせいで、データが十分に記録されないという悲劇が生じた&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;結局のところ、&lt;a href=&#34;https://kunisatolab.github.io/main/how-to-jspsych-firebase.html&#34; title=&#34;jsPsychを用いたWEB実験の実施：Firebaseでホスティング&amp;amp;データ保存しよう！&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国里先生の記事&lt;/a&gt;や&lt;a href=&#34;https://ando-roid.hatenablog.com/entry/intro_psyexp_R&#34; title=&#34;「Rで始める心理学Web実験」を書いた話&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安藤先生の記事&lt;/a&gt;を忠実に守れば悲劇なんて起こらないということがわかった&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h1 id=&#34;自己紹介&#34;&gt;自己紹介&lt;/h1&gt;
&lt;p&gt;&lt;a href=&#34;https://adventar.org/calendars/6005&#34; title=&#34;Online Psychological Experiment Advent Calendar&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Online Psychological Experiment Advent Calendar&lt;/a&gt; の21日目に登録した黒田起吏と申します。社会情報の処理過程や集団意思決定時の認知過程について、主に実験室実験（ヒトを対象とした認知行動実験）を用いて研究してきました。&lt;/p&gt;
&lt;p&gt;先日、jsPsychとFirebaseを用いたウェブ実験を行ったところ、大きなミスを犯しました。この記事ではその経緯と原因を説明します。反面教師にしていただければ幸いです。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;ウェブ実験の背景&#34;&gt;ウェブ実験の背景&lt;/h1&gt;
&lt;p&gt;COVID-19の影響で、ヒトを対象とした実験室実験を実施しにくくなっています。近頃では、&lt;a href=&#34;https://www.yomiuri.co.jp/national/20201207-OYT1T50081/&#34; title=&#34;同じ端末のキーボード共有、クラスター原因か…ボタンに「高さ」あるタイプ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;共用のキーボードからコロナに感染した話&lt;/a&gt;もあるそうです。この状況では、協力してくださる方々が安心して実験に参加できるとは思えないため、いまは実験室実験を自粛しています。&lt;/p&gt;
&lt;p&gt;そのため今年度から、私はjsPsychとFirebaseを用いてウェブ実験を行ってきました。実施方法については、&lt;a href=&#34;https://kunisatolab.github.io/main/how-to-jspsych-firebase.html&#34; title=&#34;jsPsychを用いたWEB実験の実施：Firebaseでホスティング&amp;amp;データ保存しよう！&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国里先生の記事&lt;/a&gt;や&lt;a href=&#34;https://ando-roid.hatenablog.com/entry/intro_psyexp_R&#34; title=&#34;「Rで始める心理学Web実験」を書いた話&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安藤先生の記事&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;&lt;u&gt;結論としては、2つの記事の内容を忠実に守ればトラブルは起きません。&lt;/b&gt;&lt;/u&gt;しかし、私は浅知恵を働かせてしまい、記事の内容を忠実には守りませんでした。結局のところ、それが悲劇の原因でした。&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;悲劇の経緯&#34;&gt;悲劇の経緯&lt;/h1&gt;
&lt;p&gt;2020年12月14日、ウェブ実験の参加者をメールで募集しました。このウェブ実験は「参加希望者がURLからサイトにアクセスし、自分のペースで80試行の課題に取り組む」というシンプルなものです。サンプルサイズについては、63名を計画していました。&lt;/p&gt;
&lt;p&gt;しばらくして、70名程度（脱落者や外れ値がいるかもしれないと考えていたので、63名より若干多めに実施）のデータが集まりました。FirebaseからJSONデータをエクスポートし、データが記録されているかを確認しました。&lt;/p&gt;
&lt;p&gt;すると、下の図のような結果が得られました。X軸は各参加者、Y軸は記録できた試行数を表しています。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;img/dataloss.png&#34; alt=&#34;dataloss&#34;&gt;&lt;/p&gt;
&lt;p&gt;OMG。&lt;u&gt;&lt;strong&gt;全80試行を記録できた人が、たった8人しかいません。残り60数名では、大なり小なり欠損が生じてしまっています。&lt;/strong&gt;&lt;/u&gt;なぜこのようなことが起きてしまったのでしょうか？&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;悲劇の原因と解決策&#34;&gt;悲劇の原因と解決策&lt;/h1&gt;
&lt;p&gt;結論から言うと、Firebaseへのデータの記録方法が間違っていたのが原因でした。まず、正解（&lt;a href=&#34;https://kunisatolab.github.io/main/how-to-jspsych-firebase.html&#34; title=&#34;jsPsychを用いたWEB実験の実施：Firebaseでホスティング&amp;amp;データ保存しよう！&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国里先生の記事&lt;/a&gt;や&lt;a href=&#34;https://ando-roid.hatenablog.com/entry/intro_psyexp_R&#34; title=&#34;「Rで始める心理学Web実験」を書いた話&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安藤先生の記事&lt;/a&gt;で紹介されている方法）を見ていきます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;正解&#34;&gt;正解&lt;/h2&gt;
&lt;p&gt;正解のやり方では、以下のようなコードでデータを記録します。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;jsPsych.init({
  timeline: timeline,
  on_finish: function() {
    firebase.database().ref(exp_id).set({
      data: jsPsych.data.get().values()
    })
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これが意味しているのは「&lt;strong&gt;&lt;u&gt;実験が全て終わったら、これまでのデータを一括で記録する&lt;/u&gt;&lt;/strong&gt;」ということです。こうしておけば、データはきちんと記録されます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;不正解今回やってしまったこと&#34;&gt;不正解（今回やってしまったこと）&lt;/h2&gt;
&lt;p&gt;しかし、私は浅知恵を働かせてしまいました。どのような浅知恵だったかを説明します。&lt;/p&gt;
&lt;p&gt;まず、&lt;a href=&#34;https://kunisatolab.github.io/main/how-to-jspsych-firebase.html&#34; title=&#34;jsPsychを用いたWEB実験の実施：Firebaseでホスティング&amp;amp;データ保存しよう！&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国里先生の記事&lt;/a&gt;や&lt;a href=&#34;https://ando-roid.hatenablog.com/entry/intro_psyexp_R&#34; title=&#34;「Rで始める心理学Web実験」を書いた話&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安藤先生の記事&lt;/a&gt;を読んだとき、素朴にこう思いました。&lt;/p&gt;
&lt;br&gt;
&lt;blockquote&gt;
&lt;p&gt;この方法（正解バージョン）だと、実験の途中で参加者が脱落したら、データを記録できないのでは？？？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;br&gt;
&lt;p&gt;実際、この考え自体は正しいです（おそらくは。でもあまり自信ないです）。そこで私は「&lt;strong&gt;&lt;u&gt;各試行が終わるたびにデータを記録&lt;/u&gt;&lt;/strong&gt;」するようにしました。下のようなコードです。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;// 以下のコードは不正解なので真似しないでください!!

// 80試行のタイムライン。
// 各試行の最後（参加者の反応後）にこれまでの全てのデータを逐一記録
const timeline = {
  timeline: [fixation, stimulus, response],
  timeline_variables: variables, // 80試行のパラメタ
  repetitions: 1,
  on_finish: function() {
    firebase.database().ref(exp_id).set({
      data: jsPsych.data.get().values()
    })
  }
};

// 実験の最後にもついでにデータを記録
jsPsych.init({
  timeline: timeline,
  on_finish: function() {
    firebase.database().ref(exp_id).set({
      data: jsPsych.data.get().values()
    })
  }
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;実際、このコードは動くし、データも記録できます。&lt;/p&gt;
&lt;p&gt;ただしそれは、1人ないし少人数が同時に取り組んでいる場合だけです。&lt;u&gt;&lt;strong&gt;つまり、自分1人でテストする限り、このコードが不具合を起こすことはほとんどありません。しかし、複数人が同時にこの課題に取り組むと、データの欠損が生じてしまいます。&lt;/strong&gt;&lt;/u&gt;&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;何が起きていたか&#34;&gt;何が起きていたか？&lt;/h2&gt;
&lt;p&gt;データの欠損に気がついたとき、私は以下の3つが原因かもしれないと考えました。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Firebaseが無料プランだった（しょぼかった）&lt;/li&gt;
&lt;li&gt;同時に参加した人数が多く、それがサーバに負荷をかけた&lt;/li&gt;
&lt;li&gt;データを毎試行（頻繁に）記録して、それがサーバに負荷をかけた&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;p&gt;まず1についてです。Firebaseに詳しくないので確かなことは言えませんが「課金すればいいんじゃないの」と思い、早速自分のクレジットカードを登録しました。つまり1の原因は（おそらく）潰せました。&lt;/p&gt;
&lt;p&gt;次に2についてです。同時接続数を確認したところ、最大12人が同時接続していたことがわかりました。12人が同時接続するだけでサーバが駄目になるサービスだとしたら、Firebaseの商売は成り立ってないはずなので、この可能性はかなり低いと考えました。ただ、一応その可能性は切り捨てませんでした。&lt;/p&gt;
&lt;p&gt;残った最後の可能性として、3の原因が一番大きそうだと考えるに至りました。これまで私は「毎試行データを記録するぐらい、Firebaseサンなら大丈夫でしょ」と思っていましたが、そうではないかもしれないと考え直したということです。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;テスト&#34;&gt;テスト&lt;/h1&gt;
&lt;h2 id=&#34;テスト状況&#34;&gt;テスト状況&lt;/h2&gt;
&lt;p&gt;上の説を検証するため、12月16日にテストを行いました。テスト状況は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Firebaseのプランをアップグレードした&lt;/li&gt;
&lt;li&gt;実験データを「実験の最後に一括で記録」するようにした。つまり、国里先生や安藤先生のやり方に忠実に従ったということ&lt;/li&gt;
&lt;li&gt;13人（研究室のメンバーなど）に頼み、同時にウェブサイトに接続して課題に取り組んでもらった&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;結果&#34;&gt;結果&lt;/h2&gt;
&lt;p&gt;記録されたデータを確認したところ、13人全員のデータ全てが記録されていました。つまり成功です。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;考察&#34;&gt;考察&lt;/h2&gt;
&lt;p&gt;コードを正解バージョンに修正したことがかなり有効だったと考えられます。もちろんFirebaseのアップグレードが有効だったという可能性は残っていますが、とにかくデータ欠損の問題は解決しました。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;教訓&#34;&gt;教訓&lt;/h1&gt;
&lt;p&gt;まとめると、jsPsychとFirebaseで実験を実施するときは、&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&#34;https://kunisatolab.github.io/main/how-to-jspsych-firebase.html&#34; title=&#34;jsPsychを用いたWEB実験の実施：Firebaseでホスティング&amp;amp;データ保存しよう！&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;国里先生の記事&lt;/a&gt;や&lt;a href=&#34;https://ando-roid.hatenablog.com/entry/intro_psyexp_R&#34; title=&#34;「Rで始める心理学Web実験」を書いた話&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;安藤先生の記事&lt;/a&gt;にあるように「実験が全て終わったときにデータを記録する」のが良い&lt;/li&gt;
&lt;li&gt;（インテンシブに）データを取る場合、Firebaseは一応有料プランにしておくのが良いかもしれない。無料枠の中で済んだらどうせお金を払わずに済むので（おそらくは。詳しくはご自身の責任でお調べください）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ということになります。&lt;/p&gt;
&lt;p&gt;私のようにやらかす人は少ないとは思いますが、念のためご注意いただければと思います。&lt;/p&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://shorebird.hatenablog.com/entry/2020/01/11/113010&#34; title=&#34;『文化がヒトを進化させた』の書評&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;『文化がヒトを進化させた』の書評&lt;/a&gt;にもあるように、まさに「累積的に進化した文化のコンテンツは個人の体験や思考の限界を超えて有用なことが多いからなぜそうするのかわからなくてもまず従うことが有利」ということでした。つまり「よくわからんけど、とりあえず言い伝えには従っておく」が正解だったということです。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>認知モデルのパラメタを最尤推定する</title>
      <link>https://kirikuroda.github.io/post/2020/09/05/mle-delay-discounting/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/09/05/mle-delay-discounting/</guid>
      <description>


&lt;div id=&#34;はじめに&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;div id=&#34;背景&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;いま一部の心理学領域で、認知モデルを立ててそのパラメタを推定する、あるいは、複数のモデルの良さを比較する、というデータ分析がスタンダードになりつつあります。また、その分析手法として、主にStanを使ったベイズ推定が取り上げられるようになっています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;しかし、一体どれだけの人（特に学部生）がベイズ推定についていけているでしょうか？&lt;/strong&gt;　実際には、「ベイズ推定どころか最尤推定って何？　具体的にはどう計算するの？　どういうコードを書けばいいの？　そもそも認知モデルって何？」となってしまう&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;場合が多いのでは？、というのが私の肌感覚です。&lt;/p&gt;
&lt;p&gt;そういう「置いてけぼり感」を覚えてしまうことに無理はないです。現状、心理学（特に社会心理学）の授業で、認知モデルに関するトレーニングを受ける機会は少ないからです&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;このページの概要&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;このページの概要&lt;/h2&gt;
&lt;p&gt;そこでこのページでは、&lt;strong&gt;遅延割引課題&lt;/strong&gt;を例として、認知モデルのパラメタをどうやって&lt;strong&gt;最尤推定&lt;/strong&gt;するかを、具体的に見ていくことにします。推定にはRを使います。&lt;/p&gt;
&lt;p&gt;なお、この課題については、『&lt;a href=&#34;http://www.asakura.co.jp/books/isbn/978-4-254-12842-0/&#34; title=&#34;社会科学のためのベイズ統計モデリング&#34;&gt;社会科学のためのベイズ統計モデリング&lt;/a&gt;』の第9章を参考にしています。より詳しく知りたい方は、そちらを読んでください。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;遅延割引のモデルを解説&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;遅延割引のモデルを解説&lt;/h1&gt;
&lt;div id=&#34;遅延割引課題とは&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;遅延割引課題とは&lt;/h2&gt;
&lt;p&gt;遅延割引課題とは、「&lt;strong&gt;いますぐに小さい金額をもらうか、だいぶ先になっちゃうけどより大きい金額をもらうか&lt;/strong&gt;」のどちらかを選ぶという課題です。&lt;/p&gt;
&lt;p&gt;ここでは、「&lt;strong&gt;いますぐにr円をもらうか、n日後に50000円をもらうか&lt;/strong&gt;」のどちらかを選ぶことになったとします。もっと具体的に考えるために、以下の2つの例を考えてみましょう。&lt;/p&gt;
&lt;p&gt;まず、「&lt;strong&gt;いますぐに5000円をもらうか、30日後に50000円をもらうか&lt;/strong&gt;」と聞かれたら、どっちを選びますか？　おそらく、多くの人は「&lt;strong&gt;30日後に50000円&lt;/strong&gt;」を選ぶのではないでしょうか。&lt;/p&gt;
&lt;p&gt;次に、「&lt;strong&gt;いますぐに45000円をもらうか、720日後に50000円をもらうか&lt;/strong&gt;」と聞かれたら、どっちを選びますか？　ここでは逆に、「&lt;strong&gt;いますぐに45000円&lt;/strong&gt;」を選ぶ人が多いと思います。&lt;/p&gt;
&lt;p&gt;イメージはつきましたか？　この例からわかるように、遅延割引課題は「&lt;strong&gt;長期的利益のために、人々が目先の利益をどれくらい我慢できるか&lt;/strong&gt;」を測定するものです。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;遅延割引のモデル&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;遅延割引のモデル&lt;/h2&gt;
&lt;p&gt;さて、「&lt;strong&gt;人が長期的な利益をどれくらい良いと感じるか&lt;/strong&gt;」は、以下の式（モデル）で表現できるとされています&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
U(A,t) = U(A)\frac{1}{1+kt}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;それぞれの記号は以下の内容を表しています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;：金額。ここでは50000円だと考えてください&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;：何日後に&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;（すなわち50000円）をもらえるか&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A, t)\)&lt;/span&gt;：&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;（50000円）をもらった場合の「嬉しさ」&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A)\)&lt;/span&gt;：いますぐに&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;（50000円）をもらった場合の嬉しさ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;：&lt;strong&gt;遅延割引パラメタ&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;では、この&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;（遅延割引パラメタ）とは具体的にどういうものなのでしょうか？　それを理解するために、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;をいじってみましょう。&lt;/p&gt;
&lt;p&gt;Figure 1の横軸は「t日」、縦軸は「そのとき50000円をもらったときの嬉しさ（すなわち、&lt;span class=&#34;math inline&#34;&gt;\(U(A,t)\)&lt;/span&gt;）」を表しています。ここでは、&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日を0〜30で変化させ、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;を0から0.5まで0.05刻みで変化させています。&lt;/p&gt;
&lt;p&gt;この図からどういうことが読み取れるでしょうか？&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

expand_grid(t = 0:30, k = seq(0, 0.5, 0.05)) %&amp;gt;%
  mutate(u = 50000 * (1 / (1 + k * t))) %&amp;gt;%
  ggplot(aes(x = t, y = u, group = k, color = k)) +
  geom_line() +
  scale_color_viridis_c() +
  labs(x = &amp;quot;t（日）&amp;quot;, y = &amp;quot;t日後に50000円もらったときの嬉しさ&amp;quot;) +
  theme_minimal(base_family = &amp;quot;ヒラギノ角ゴシック W3&amp;quot;) +
  theme(axis.text = element_text(color = &amp;quot;#333333&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:setup&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;index_files/figure-html/setup-1.png&#34; alt=&#34;t日後に50000円もらったときの嬉しさ&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: t日後に50000円もらったときの嬉しさ
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;まず、&lt;span class=&#34;math inline&#34;&gt;\(t = 0\)&lt;/span&gt;のとき、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;がどんな値であれ、縦軸（50000円もらったときの嬉しさ）は50000円です。&lt;span class=&#34;math inline&#34;&gt;\(t = 0\)&lt;/span&gt;は「今すぐ」と同じだからです。&lt;/p&gt;
&lt;p&gt;次に、&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;が大きくなるほど、「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円」の嬉しさは低くなっています。&lt;/p&gt;
&lt;p&gt;また、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が大きくなるほど（線が明るい色になるほど）、「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円」の嬉しさは低くなっています。これを引っ張って考えると、「&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が大きい人ほど、今すぐの利益に目がくらんでしまいがち&lt;/strong&gt;」ということになります&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;肢選択のモデル&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2肢選択のモデル&lt;/h2&gt;
&lt;p&gt;では次に「2つの選択肢（目先の利益 vs. 長期的な利益）をどうやって選ぶか」のモデルを考えてみましょう。&lt;/p&gt;
&lt;p&gt;ここでは「今すぐ5000円をもらうか、1ヶ月後に50000円をもらうか」を選ぶ状況を例とします。私たちは多くの場合、「1ヶ月後に50000円」を選ぶでしょう。&lt;/p&gt;
&lt;p&gt;しかし、人間というものは、そこまで完璧ではありません。もし「ねえ、今すぐ5000円あげるけど、欲しいよね？」と100回も聞かれたら、何回かは誘惑にかられて「今すぐ5000円」を選んでしまうかもしれません。&lt;/p&gt;
&lt;p&gt;このような現象を表すため、よくロジスティック関数&lt;a href=&#34;#fn6&#34; class=&#34;footnote-ref&#34; id=&#34;fnref6&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;というものが用いられます。遅延割引課題の例では、以下のように書くことができます。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
P_{d} = \frac{1}{1+\exp(-\beta[U(A^{d})-U(A^{s})])}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;記号の意味は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{d}\)&lt;/span&gt;：遅延報酬（&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円）を選ぶ確率（0〜1の値）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A^{d})\)&lt;/span&gt;：遅延報酬をもらった時の嬉しさ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A^{s})\)&lt;/span&gt;：即時報酬（今すぐの報酬）をもらった時の嬉しさ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;：逆温度パラメタ（&lt;strong&gt;嬉しさの差分&lt;/strong&gt;にどれくらい敏感に反応するか）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;詳しくは「ロジスティック関数」などで調べてほしいのですが、この式で大事なのは以下の2点です。&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A^{d})-U(A^{s})\)&lt;/span&gt;が大きくなるほど&lt;span class=&#34;math inline&#34;&gt;\(P_{d}\)&lt;/span&gt;も大きくなる。&lt;/strong&gt;すなわち、遅延報酬が即時報酬よりも魅力的であるほど、遅延報酬を選ぶ確率が高くなるということです。裏を返すと、即時報酬のほうが魅力的であるほど、遅延報酬を選ぶ確率が低くなる（つまり、即時報酬を選ぶ確率が高くなる）ということも表しています。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;が大きいほど、「嬉しさ」の差分に強く反応する。&lt;/strong&gt;つまり、&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;が大きい場合、嬉しさの大きい方を忠実に選ぶようになるということです。逆に&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;が0に近いほど、どちらを選ぶかはランダムに近づく（「嬉しさ」の影響力が弱くなり、選択肢をでたらめに選ぶようになる）ということも表しています。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;さて、遅延割引課題を用いた研究で知りたいのは、&lt;strong&gt;ある人（参加者）がどれくらい目先の利益に目がくらみがちか&lt;/strong&gt;、そして、&lt;strong&gt;ある人（参加者）がどれくらい「嬉しさ」の差分に強く反応するか&lt;/strong&gt;ということです。これを言い換えると、&lt;strong&gt;ある人がどれくらいの&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;（遅延割引パラメタ）を持っているか&lt;/strong&gt;、&lt;strong&gt;ある人がどれくらいの&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;（逆温度パラメタ）を持っているか&lt;/strong&gt;ということになります。&lt;/p&gt;
&lt;p&gt;認知モデルのパラメタを推定するというのは、まさに「ある人がどれくらいのパラメタ（認知的な傾向）を持っているか」を探ろうとする分析を意味しています。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;実際に遅延割引パラメタを推定する&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;実際に遅延割引パラメタを推定する&lt;/h1&gt;
&lt;div id=&#34;実験データを作ってみる&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;実験データを作ってみる&lt;/h2&gt;
&lt;p&gt;ここで具体的な分析方法を説明したいのですが、まだ手元にはデータがありません。&lt;/p&gt;
&lt;p&gt;そこで、ある1人の参加者が50回の遅延割引課題に取り組んだと仮定します。具体的には「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円をもらうか、今すぐ&lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;円をもらうか」を選んだとしましょう。各回で、日数&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;は｛30, 90, 180, 360, 720｝のいずれか、今すぐの報酬&lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;は｛5000, 1000, …, 50000｝のいずれかとします（5通り×10通りなので50回の課題、ということです）。では、下のコードのように仮想的なデータを作り、&lt;code&gt;data&lt;/code&gt;というデータフレームとして保存してみましょう&lt;a href=&#34;#fn7&#34; class=&#34;footnote-ref&#34; id=&#34;fnref7&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;set.seed(1)
data &amp;lt;- expand_grid(
  t = c(30, 90, 180, 360, 720),
  r = seq(5000, 50000, 5000)
  ) %&amp;gt;%
  mutate(
    u_delay = 50000 * (1 / (1 + 0.01 * t)),
    p = 1 / (1 + exp(-0.00005 * (u_delay - r)))
  ) %&amp;gt;%
  group_by(row_number()) %&amp;gt;%
  mutate(choice = rbinom(1, 1, p))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;では、この参加者は遅延報酬（「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円」）を何回選んだのでしょうか？　遅延報酬を選んだ場合、&lt;code&gt;data&lt;/code&gt;の&lt;code&gt;choice&lt;/code&gt;という変数は&lt;code&gt;1&lt;/code&gt;になっています。逆に即時報酬（「すぐに&lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;円」）を選んだ場合、&lt;code&gt;choice&lt;/code&gt;は&lt;code&gt;0&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;参加者の選択を下にプロットしてみました。横軸は遅延日数&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;、縦軸は選択（0か1）、各パネルの上の数字は即時報酬の金額を表しています。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;%
  ggplot(aes(x = t, y = choice)) +
  geom_point() +
  scale_y_continuous(breaks = c(0, 1)) +
  facet_wrap(~r)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;index_files/figure-html/unnamed-chunk-2-1.png&#34; alt=&#34;ある参加者がどれくらい遅延報酬を選んだか&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: ある参加者がどれくらい遅延報酬を選んだか
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;素朴にパラメタを推定してみる&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;素朴にパラメタを推定してみる&lt;/h2&gt;
&lt;p&gt;さて、どのようにパラメタを推定すればよいのでしょうか？　まず、素朴なアイデアから出発してみます。&lt;/p&gt;
&lt;p&gt;たとえば、「なんとなくだけど、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;は0.1で、&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;は0.0001じゃね？」と考えたとしましょう。このとき、これらのパラメタの値はどれくらいふさわしいでしょうか？　また、そのふさわしさはどのように評価（計算）されるべきでしょうか？&lt;/p&gt;
&lt;p&gt;とりあえず、上で説明した2つのモデルに代入してみましょう。ここでは、「今すぐ5000円」と「30日後に50000円」を比べた場合を考えてみます。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;t &amp;lt;- 30
k &amp;lt;- 0.1
beta &amp;lt;- 0.0001

# u_delay：遅延報酬のU
u_delay &amp;lt;- 50000 * (1 / (1 + 0.1 * t))

# 30日後に50000円を選ぶ確率
p &amp;lt;- 1 / (1 + exp(-beta * (u_delay - 5000)))

print(p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.6791787&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;さて、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;としたとき、遅延報酬を選ぶ確率は0.6791787になりました。では、実際のデータはどうだったでしょうか？ つまり、「今すぐ5000円 vs. 30日後に50000円」のとき、どっちを選んでいたでしょうか？&lt;/p&gt;
&lt;p&gt;Figure 2を見ると、参加者が遅延報酬（30日後に50000円）を選んでいたということがわかります。では、上の計算で出てきた「遅延報酬を選ぶ確率は0.6791787」と「参加者が実際に遅延報酬を選んでいたという事実」はどのように関係しているのでしょうか。&lt;/p&gt;
&lt;p&gt;「遅延報酬を選ぶ確率」というのは、「『遅延報酬を選ぶ』という結果が得られる確率」と言い換えることができます。この「『遅延報酬を選ぶ』という結果が得られる確率」は、パラメタ&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;と&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;を色々な値にすれば、それに応じて様々な値に変動します。&lt;/p&gt;
&lt;p&gt;ここで、「参加者が実際に遅延報酬を選んで」いたとしましょう。このとき、適当にパラメタを代入して、「『遅延報酬を選ぶ』という結果が得られる確率」が高かった場合、それは何を意味しているでしょうか。&lt;/p&gt;
&lt;p&gt;日常言語で表すと、「参加者は遅延報酬を選んでいた。適当にパラメタを代入したら、遅延報酬を選ぶ確率は高いらしい。これって実際のデータと結構近いじゃん」ということになります。さらにこれを引っ張ると、「結構近いんだから、このパラメタって、もしかして良い線行ってるんじゃね？」となります。逆に、予測が外れた場合は、そのパラメタはあまりよろしくないと言えます。&lt;/p&gt;
&lt;p&gt;つまり、「ある結果が得られている。そこで、適当にパラメタを設定したら、その結果が得られる確率も高いようだ。だったら、そのパラメタは『ふさわしい』んじゃないか」ということです。このようなパラメタの「ふさわしさ」（&lt;strong&gt;パラメタを設定したとき、手元にあるデータが得られる確率&lt;/strong&gt;）を真面目に言うと「尤度」になります。また、尤度をもとにパラメタを推定する方法を最尤推定と言います。&lt;/p&gt;
&lt;p&gt;この例では、「いま、参加者が遅延報酬を選んだことがわかっている。そこで、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;としたとき、遅延報酬を選ぶ確率は0.6791787だった」ということになります。すなわち、尤度は0.6791787です&lt;a href=&#34;#fn8&#34; class=&#34;footnote-ref&#34; id=&#34;fnref8&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;尤度を計算する&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;尤度を計算する&lt;/h2&gt;
&lt;p&gt;では、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;とし、全50回の尤度を計算してみましょう。まず、以下のコードを実行します。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;t &amp;lt;- 30
k &amp;lt;- 0.1
beta &amp;lt;- 0.0001

data %&amp;gt;%
  # 遅延報酬のUと、遅延報酬を選ぶ確率pを計算
  mutate(
    u_delay = 50000 * (1 / (1 + k * t)),
    p = 1 / (1 + exp(-beta * (u_delay - r)))
  ) %&amp;gt;%
  # 遅延報酬を選ぶ確率pを抽出
  pull(p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.679178699 0.562176501 0.437823499 0.320821301 0.222700139 0.148047198
##  [7] 0.095349465 0.060086650 0.037326887 0.022977370 0.500000000 0.377540669
## [13] 0.268941421 0.182425524 0.119202922 0.075858180 0.047425873 0.029312231
## [19] 0.017986210 0.010986943 0.441064710 0.323695074 0.224986141 0.149714490
## [25] 0.096490497 0.060834074 0.037802587 0.023274618 0.014247244 0.008690106
## [31] 0.409782432 0.296323939 0.203450772 0.134137019 0.085891464 0.053918000
## [37] 0.033411753 0.020535219 0.012556698 0.007653837 0.393766567 0.282619107
## [43] 0.192864008 0.126583888 0.080801479 0.050617863 0.031325176 0.019236783
## [49] 0.011756686 0.007163930&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上に表示されているのは、遅延報酬を選ぶ確率&lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;です。&lt;/p&gt;
&lt;p&gt;しかし、これをそのまま最尤推定に使うことはできません。なぜなら、尤度とは「あるパラメタを設定したときに、&lt;strong&gt;手元にあるデータ&lt;/strong&gt;が得られる確率」だからです。実験では、参加者が即時報酬を選ぶ場合も当然あるので、その場合は「即時報酬を選ぶ確率」を使わないといけません。したがって、各回の尤度（&lt;code&gt;likelihood&lt;/code&gt;）は以下のようになります。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;likelihood &amp;lt;- data %&amp;gt;%
  # 遅延報酬のUと、遅延報酬を選ぶ確率pを計算
  # さらに、参加者の選択に応じて条件分岐をして尤度を計算
  mutate(
    u_delay = 50000 * (1 / (1 + k * t)),
    p = 1 / (1 + exp(-beta * (u_delay - r))),
    likelihood = if_else(choice == 1, p, 1 - p)
  ) %&amp;gt;%
  pull(likelihood)

likelihood&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.67917870 0.56217650 0.43782350 0.67917870 0.22270014 0.85195280
##  [7] 0.90465054 0.06008665 0.03732689 0.97702263 0.50000000 0.37754067
## [13] 0.73105858 0.18242552 0.88079708 0.92414182 0.04742587 0.02931223
## [19] 0.98201379 0.01098694 0.55893529 0.32369507 0.77501386 0.85028551
## [25] 0.90350950 0.93916593 0.96219741 0.97672538 0.01424724 0.99130989
## [31] 0.40978243 0.70367606 0.79654923 0.86586298 0.08589146 0.94608200
## [37] 0.03341175 0.97946478 0.98744330 0.99234616 0.60623343 0.28261911
## [43] 0.19286401 0.87341611 0.91919852 0.05061786 0.96867482 0.98076322
## [49] 0.98824331 0.99283607&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;対数尤度を計算する&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;対数尤度を計算する&lt;/h2&gt;
&lt;p&gt;では、ここで全50回の尤度を1つの指標にまとめたいと思います（まとめたいですよね？）。このとき、直観的には尤度を足し算すれば良いんじゃないか、と思うかもしれませんが、それは間違いです。&lt;/p&gt;
&lt;p&gt;正解は「かけ算」です。詳しい説明は適宜教科書を読むなり、ググってもらえるとありがたいです&lt;a href=&#34;#fn9&#34; class=&#34;footnote-ref&#34; id=&#34;fnref9&#34;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;。簡単な例で言えば、「3回連続でじゃんけんに勝つ確率は？」と聞かれたとき、「1/3を3回足して1」ではなく、「1/3を3回かけ算して1/27」と答えるのが正解になるのと同じ理屈です。&lt;/p&gt;
&lt;p&gt;では、上で求めた尤度を全部かけ算してみましょう。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;# prod()で、要素を全部かけあわせることになる
prod(likelihood)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.143327e-20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;これは0.00000000000000000001143327を表しています。&lt;/p&gt;
&lt;p&gt;ちっさ！って思うのではないでしょうか。と同時に、「やっぱ、パソコンはこんな細かい計算できて偉いなあ」と思う人がいるかもしれません。&lt;/p&gt;
&lt;p&gt;しかし、残念ながらそれは間違いです。あまりに数字が小さいと、パソコンの計算にも誤差が生じてしまいます&lt;a href=&#34;#fn10&#34; class=&#34;footnote-ref&#34; id=&#34;fnref10&#34;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;これを防ぐため、尤度を計算するときは、&lt;strong&gt;対数を取る&lt;/strong&gt;というのが決まりになっています。なぜなら、かけ算の対数を取ると足し算になるという便利な性質があるからです&lt;a href=&#34;#fn11&#34; class=&#34;footnote-ref&#34; id=&#34;fnref11&#34;&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;。対数を取って求めた尤度を「対数尤度」と言います。&lt;/p&gt;
&lt;p&gt;また、対数は単調増加関数なので、「尤度の積が大きい（もっともらしい）場合は、その対数も大きくなる」という関係が成り立ちます。対数、便利です。&lt;/p&gt;
&lt;p&gt;では、対数尤度を計算し、全部を足し算してみましょう。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;sum(log(likelihood))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -45.91776&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;確認のため、尤度を全部掛け算したやつの対数を取ってみましょう。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;log(prod(likelihood))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -45.91776&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;ちゃんと2つが一致しました。ただし、データの数が多いほどかけ算の誤差は大きくなるので、やはり対数を取ってから足し算をするようにしましょう。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;optimでパラメタを推定する&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;optimでパラメタを推定する&lt;/h2&gt;
&lt;p&gt;さて、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;としたときの50回の対数尤度は-45.91776になりました。&lt;/p&gt;
&lt;p&gt;で？　それが何？&lt;/p&gt;
&lt;p&gt;そうです。これだけでは、まだ何も言えていません。他のパラメタの候補も調べないと、どのパラメタが良さそうかはわかりません。&lt;/p&gt;
&lt;p&gt;では、どうすればよいでしょうか？　素朴に考えたら、有り得そうな&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;や&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;を片っ端から代入して対数尤度を計算する、というのが良さそうです。しかし、そんな時間は私たちにはありません。&lt;/p&gt;
&lt;p&gt;そこで使うのが、Rの最適化関数&lt;code&gt;optim&lt;/code&gt;です。最適化関数とは、ある関数の最大値／最小値を求めるための道具だと考えてください。&lt;/p&gt;
&lt;p&gt;いま私たちがやりたいのは、対数尤度が最も大きくなりそうなパラメタ&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;と&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;の組み合わせを調べるということです。つまり、&lt;code&gt;optim&lt;/code&gt;を使って、対数尤度（関数）が最大化されるような&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;と&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;を見つければ目的達成ということになります。&lt;/p&gt;
&lt;p&gt;では、具体的な書き方を説明します。まず、対数尤度関数（&lt;code&gt;ll_delay&lt;/code&gt;）を自分で定義します。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;# 関数を定義する
ll_delay &amp;lt;- function(param, data) {

  # param[1]はk、param[2]はbetaを表している
  # dataは参加者のデータフレームそのものを表している

  data %&amp;gt;%
    # 毎回の対数尤度を計算する
    mutate(
      u_delay = 50000 * (1 / (1 + param[1] * t)),
      p = 1 / (1 + exp(-param[2] * (u_delay - r))),
      likelihood = if_else(choice == 1, p, 1 - p),
      ll = log(likelihood)
    ) %&amp;gt;%
    # 最後に全部足し合わせる
    pull(ll) %&amp;gt;%
    sum()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;これを&lt;code&gt;optim&lt;/code&gt;に突っ込みます。&lt;code&gt;par&lt;/code&gt;には推定したいパラメタの初期値、&lt;code&gt;fn&lt;/code&gt;には最適化したい関数を入れます。&lt;code&gt;control = list(fnscale = -1)&lt;/code&gt;とすると、関数の最大化が行われるようになります。その他の引数（この例では&lt;code&gt;data&lt;/code&gt;）では、&lt;code&gt;ll_delay&lt;/code&gt;にどんな引数を渡すかを指示してあげます。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;optim(par = c(0.1, 0.0001), fn = ll_delay, data = data, control = list(fnscale = -1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $par
## [1] 0.0132120062 0.0000423154
## 
## $value
## [1] -30.70504
## 
## $counts
## function gradient 
##       89       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;結果の&lt;code&gt;par&lt;/code&gt;が推定値を表しています。&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が0.0132120062、&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;は0.0000423154でした。&lt;/p&gt;
&lt;p&gt;では、正解は何だったのでしょうか？　正解は、データを作ったコードの中に隠れています。改めてコードを見てみましょう。&lt;/p&gt;
&lt;pre class=&#34;r language-r&#34;&gt;&lt;code&gt;set.seed(1)
data &amp;lt;- expand_grid(
  t = c(30, 90, 180, 360, 720),
  r = seq(5000, 50000, 5000)
  ) %&amp;gt;%
  mutate(
    u_delay = 50000 * (1 / (1 + 0.01 * t)),
    p = 1 / (1 + exp(-0.00005 * (u_delay - r)))
  ) %&amp;gt;%
  group_by(row_number()) %&amp;gt;%
  mutate(choice = rbinom(1, 1, p))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;最初は詳しく説明しませんでしたが、このコードでは、遅延割引と2肢選択のモデルを用いて、参加者の選択を仮想的に作っていました。とくに7行目と8行目を見てください。ここでは、参加者が&lt;span class=&#34;math inline&#34;&gt;\(k=0.01\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta=0.00005\)&lt;/span&gt;というパラメタを持つように設定しています。さて、推定結果は&lt;span class=&#34;math inline&#34;&gt;\(k=0.0132120062\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta=0.0000423154\)&lt;/span&gt;でした。まあまあ良い線行ってるのではないでしょうか。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;おわりに&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;おわりに&lt;/h1&gt;
&lt;p&gt;ここまで、駆け足で認知パラメタの最尤推定を見てきました。もちろん、まだまだ説明していないトピックはありますが、まずはここらへんの内容を押さえておくのが良いかと思います。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;私が学部生の頃もそうでした。たとえば当時、とても偉い工学系の先生に「すみません、単回帰分析の最尤推定ってどうやるんですか？」みたいなことを聞いてたレベルです。ちなみに、単回帰分析の最尤推定は心理統計の教科書に載っているし、ググればすぐに出てくるような内容です。今思えばガチで恥ずかしいですが、「知らぬは一時の恥、聞かぬは一生の恥」です。そんな質問をしていた私ですら、いま一応なんとか生きてます。（以下、かなり脱線します。）わからないことがあったときにおすすめなのは、研究室や学科の先輩に質問することです。もちろんググっても良いのですが、先輩たちも同様の難所を乗り越えている場合が多いので、同じ目線で答えてくれる可能性が高いです。ただし、自分がふだん研究室に行かなかったり、先輩と全然コミュニケーションを取ったりしていないのに、「卒論締切間際に自分が困ったときにだけ質問する」みたいな姿勢は、傍から見ていると「それは虫が良すぎじゃね？」という感じがします。「&lt;strong&gt;ふだんから細かく&lt;/strong&gt;」質問する、世間話をしておく（※先輩の機嫌を取るということではないです）、ぐらいのことをやっておいたほうが、長期的には良いと思います。このトピックだけで記事を1つ書けそうです。&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;まあ、「授業が全てを教えてくれる」という期待・態度がそもそも間違っているという説はあります。結局のところ、研究スキルなんて、試行錯誤で無理くり獲得していくものなのかもしれません。&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;この式は、双曲割引（hyperbolic discounting）と言います。&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt;は「嬉しさ（Ureshisa）」の頭文字のUではなく、本当は「効用（Utility）」の頭文字を表しています。ここで「効用」とか書いちゃうと難しくなるので、「嬉しさ」にしています。&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;ちょっとジャンプがあるかもしれませんが、わからなかった場合はゆっくり考えてみてください。日常的な例（？）でいうと、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が大きいほど、「健康診断のため1ヶ月後に3kg痩せるのは、今すぐに飴玉を1個食べるのと等しいと感じてしまう」ということです。このような人は「今すぐ飴玉2個あげるよ」と言われたら、飴玉2個を食べてしまう（目がくらんでしまう）ということになります。逆に&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が小さいと、「1ヶ月後に3kg痩せるのは、今すぐ高級マカロン100個を食べるのと等しいと感じる」ということです。このような人は「今すぐマカロン1個あげるよ」と言われても、「そんな少ないマカロンをもらうぐらいなら、我慢して減量したほうがマシ」と返事をして、拒絶することになるでしょう。&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34;&gt;&lt;p&gt;ソフトマックス関数といったほうが厳密かもしれません。詳しくは『社会科学のためのベイズ統計モデリング』を読んだり、「ソフトマックス関数　ロジスティック関数」でググったりしてみてください。&lt;a href=&#34;#fnref6&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn7&#34;&gt;&lt;p&gt;とりあえずこのコードの意味を意味を理解する必要はないです。&lt;a href=&#34;#fnref7&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn8&#34;&gt;&lt;p&gt;正直、尤度や最尤推定については他にもっと優れた記事があると思うので、わからなければ適宜ググってもらえると嬉しいです。&lt;a href=&#34;#fnref8&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn9&#34;&gt;&lt;p&gt;「積事象」や「尤度」でググってみてください。&lt;a href=&#34;#fnref9&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn10&#34;&gt;&lt;p&gt;これをアンダーフローと言います。たとえば、Rのコンソールに&lt;code&gt;1e-1000&lt;/code&gt;とか打ってみて、どうなるかを見てみましょう。&lt;a href=&#34;#fnref10&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn11&#34;&gt;&lt;p&gt;この説明は端折りますが、一応文系数学の範囲です。「尤度」でググると、この内容は必ず説明されているので、適宜調べてみてください。&lt;a href=&#34;#fnref11&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>PsychoPy Coderチュートリアル</title>
      <link>https://kirikuroda.github.io/post/2020/09/02/psychopy-coder-tutorial/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/09/02/psychopy-coder-tutorial/</guid>
      <description>&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;
&lt;h2 id=&#34;想定している読者層&#34;&gt;想定している読者層&lt;/h2&gt;
&lt;p&gt;このチュートリアルでは、以下のタイプの読者を想定しています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;実験プログラムを書かなきゃいけなくなった心理学（特に社会心理学）系の学部生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卒論で（いきなり&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;）心理学実験のプログラムを書かなくちゃいけなくなった人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pythonの初心者本は一通り読んだけど、いざPsychoPyになるとよくわからない人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coderのどこから手を着ければいいかわからない人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;せっかくやるならBuilderじゃなくてCoderがいい、でもよくわからない、という人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CoderにDemosってやつがあるらしいけど、英語を読むことに苦手意識がある（あるいは、Demosの存在を知らない）という人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;時間がない人&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;既に公開されている優れたチュートリアル&#34;&gt;既に公開されている優れたチュートリアル&lt;/h2&gt;
&lt;p&gt;PsychoPyのCoderについては、既に優れたチュートリアルがいくつか公開されています（参照：&lt;a href=&#34;https://qiita.com/snishym/items/8b52db0d901cf5744463&#34; title=&#34;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&lt;/a&gt;）。この「チュートリアルまとめ」、およびそこで紹介されているチュートリアルのいずれにおいても、Pythonの初歩から実験実施までが丁寧に解説されています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;このチュートリアルの特色&#34;&gt;このチュートリアルの特色（？）&lt;/h2&gt;
&lt;p&gt;このチュートリアルでは、Pythonの初歩の説明をすっ飛ばします。上で紹介した記事も含め、もっと優れた資料や書籍が山のようにあるからです。&lt;/p&gt;
&lt;p&gt;その代わりに、&lt;strong&gt;（社会）心理学の実験で割と使うと思われる機能&lt;/strong&gt;に絞って話を進めます。くわえてこのチュートリアルでは、&lt;strong&gt;最初から完成したコードを見て&lt;/strong&gt;、それを順に解説していくという方針を取ります。「該当するコードをコピペしていけば、自分の実験も書けるんじゃないか？」と思ってもらえることを狙っています。&lt;/p&gt;
&lt;p&gt;主に説明するのは以下の機能です：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ダイアログボックス&lt;/li&gt;
&lt;li&gt;データをCSVに記録&lt;/li&gt;
&lt;li&gt;テキスト刺激の呈示&lt;/li&gt;
&lt;li&gt;キー押しの検出&lt;/li&gt;
&lt;li&gt;クリックの検出&lt;/li&gt;
&lt;li&gt;反応時間の計測&lt;/li&gt;
&lt;li&gt;マウスやキー押しに応じて刺激の色を変える&lt;/li&gt;
&lt;li&gt;反応に応じたフィードバック　etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;このチュートリアルの試みがどこまでうまくいくかわかりませんが、とりあえずセットアップしてみましょう。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;いきなりやってみるタイプのチュートリアル&#34;&gt;いきなりやってみるタイプのチュートリアル&lt;/h1&gt;
&lt;h2 id=&#34;いきなりセットアップ&#34;&gt;いきなりセットアップ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;この記事では&lt;strong&gt;Mac&lt;/strong&gt;と&lt;strong&gt;PsychoPy 2020.2.3&lt;/strong&gt;を使ってます。&lt;strong&gt;この際なので、PsychoPyをアップデートしてください。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/kirikuroda/psychopy_coder_demo&#34; title=&#34;GitHubのページ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kirikuroda/psychopy_coder_demo&lt;/a&gt;からファイルをダウンロードして、PCの適当な場所に保存してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;いきなり実験&#34;&gt;いきなり実験&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先ほどダウンロードした&lt;code&gt;psychopy_coder_demo.py&lt;/code&gt;を、PsychoPy Coder（Experiment Runner）で実行してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;すると、短い課題が画面に表示されます。この課題を解説していくので、まずは課題をやってみてください。1分で終わります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（Macで）以下のようなエラーが出る場合は、&lt;a href=&#34;https://discourse.psychopy.org/t/keyboard-psychtoolbox-hid-failing-with-mac-os-catalina-update/9389&#34; title=&#34;Keyboard psychtoolbox/hid failing with Mac OS Catalina update&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;こちらのページ（英語）&lt;/a&gt;を参考にしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;File “psychtoolbox/hid.pyc”, line 137, in init
File “psychtoolbox/hid.pyc”, line 145, in _create_queue
FileNotFoundError: [Errno 2] No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;実験の構造&#34;&gt;実験の構造&lt;/h2&gt;
&lt;p&gt;実験は終わりましたか？　実験の構造を確認しましょう：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参加者のIDを入力&lt;/li&gt;
&lt;li&gt;教示が表示される&lt;/li&gt;
&lt;li&gt;Startをクリックすると課題が始まる&lt;/li&gt;
&lt;li&gt;最初に試行数が表示される&lt;/li&gt;
&lt;li&gt;次に都市名が表示される&lt;/li&gt;
&lt;li&gt;どちらの都市の人口が多いかをFかJで回答する&lt;/li&gt;
&lt;li&gt;何もせずに5秒以上経つと「Hurry up!」が表示される&lt;/li&gt;
&lt;li&gt;FかJを押すと、選んだ方の都市が黄色くなり、四角で囲まれる&lt;/li&gt;
&lt;li&gt;正解不正解のフィードバックが表示される&lt;/li&gt;
&lt;li&gt;（裏でその試行のデータが記録される）&lt;/li&gt;
&lt;li&gt;※4〜10を繰り返す&lt;/li&gt;
&lt;li&gt;実験終了のメッセージが表示される&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;p&gt;では、コードを順になぞっていきます。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;解説&#34;&gt;解説&lt;/h1&gt;
&lt;h2 id=&#34;ダイアログボックスを呈示する3846行目&#34;&gt;ダイアログボックスを呈示する（38–46行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ダイアログボックスを呈示し、参加者の情報を入力
subj_info = {&amp;quot;subj_id&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;add_here_what_you_want&amp;quot;: &amp;quot;&amp;quot;}
dialogue_box = gui.DlgFromDict(subj_info, order = [&amp;quot;subj_id&amp;quot;, &amp;quot;add_here_what_you_want&amp;quot;])

# OKならID（subj_id）を記録して実験を進める。キャンセルなら実験を中止
if dialogue_box.OK:
    subj_id = subj_info[&amp;quot;subj_id&amp;quot;]
else:
    core.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参加者の情報を入力するためのダイアログボックスを呈示しています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add_here_what_you_want&lt;/code&gt;と書いてあるように、他に記録したい情報がある場合は、後ろに付け足してください。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;データファイルの名前を作る5267行目&#34;&gt;データファイルの名前を作る（52–67行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 現在日時を記録
exp_date = data.getDateStr(&amp;quot;%Y%m%d%H%M%S&amp;quot;)

# データファイルを保存するフォルダを作る
# フォルダがなければ作る
try:
    os.makedirs(&amp;quot;data/csv&amp;quot;)
    os.makedirs(&amp;quot;data/log&amp;quot;)
# フォルダが既にある場合は何もしない
except OSError:
    pass

# データファイルの名前を作る（ID_日付）
file_name = subj_id + &amp;quot;_&amp;quot; + exp_date
file_name_csv = os.path.join(&amp;quot;data/csv/&amp;quot; + file_name + &amp;quot;.csv&amp;quot;)
file_name_log = os.path.join(&amp;quot;data/log/&amp;quot; + file_name + &amp;quot;.log&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参加者のIDと現在日時からファイル名を作っています。プログラムを実行した日時は、何らかの形で記録しておくようにしましょう。&lt;/p&gt;
&lt;p&gt;CSVファイルに行動データ、logファイルに実験のログを記録することにします。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;クイズの項目を読み込む6970行目&#34;&gt;クイズの項目を読み込む（69–70行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# クイズの項目（都市名、人口）を読み込む
city = pd.read_csv(&amp;quot;city.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この実験課題で呈示する項目（CSVファイル）を読み込んでいます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;画面マウスキーボードを設定する7680行目&#34;&gt;画面、マウス、キーボードを設定する（76–80行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 画面の座標系　units = &amp;quot;norm&amp;quot;
# 画面中心が(0, 0)、X軸が-1〜+1、Y軸が-1〜+1
win = visual.Window(width = 1200, height = 900, units = &amp;quot;norm&amp;quot;)
mouse = event.Mouse()
kb = keyboard.Keyboard()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PsychoPyでは、ふつうスクリーンを&lt;code&gt;win&lt;/code&gt;として記録します。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;都市名刺激を設定する86103行目&#34;&gt;都市名刺激を設定する（86–103行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# テキスト刺激の色と日本語フォント
color_default, color_highlight = &amp;quot;white&amp;quot;, &amp;quot;yellow&amp;quot;
font_ja = &amp;quot;ヒラギノ角ゴシック W3&amp;quot;

# 刺激（都市名）　textは毎試行変わるので、後で定義
city_1_text = visual.TextStim(win, font = font_ja)
city_2_text = visual.TextStim(win, font = font_ja)

# 刺激の呈示位置のカウンターバランス
# 都市名をX軸方向にどれくらいずらすか
city_nudge_x = 0.5
# 4試行のカウンターバランスをcity_posとして保存
city_pos = [&amp;quot;one_two&amp;quot;, &amp;quot;one_two&amp;quot;, &amp;quot;two_one&amp;quot;, &amp;quot;two_one&amp;quot;]
# city_text_posを並び替える
city_pos = np.random.permutation(city_pos)

# 試行の順序をランダマイズする。trial_order: [3, 2, 0, 1]のようになる
trial_order = np.random.permutation(range(len(city)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;テキスト刺激は&lt;code&gt;visual.TextStim()&lt;/code&gt;で作ります。日本語フォントは好きなものに修正してもらって構いません。&lt;/p&gt;
&lt;p&gt;ここでは、呈示位置のカウンターバランスと、試行順序のランダマイズもしています&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;キーを設定する105112行目&#34;&gt;キーを設定する（105–112行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# キー設定
key_left, key_right = &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;

# 押すべきキーの名前（課題中に呈示しておく）
# キーのテキストをY軸方向にどれくらいずらすか
key_text_nudge_y = 0.5
key_left_text = visual.TextStim(win, text = &amp;quot;F&amp;quot;, pos = (-city_nudge_x, key_text_nudge_y))
key_right_text = visual.TextStim(win, text = &amp;quot;J&amp;quot;, pos = (city_nudge_x, key_text_nudge_y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fが左、Jが右に対応するようにしています。&lt;/p&gt;
&lt;p&gt;また、課題中に呈示する「F」と「J」の刺激もここで作っています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;教示を定義する114121行目&#34;&gt;教示を定義する（114–121行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 教示を定義
inst_text = visual.TextStim(win, alignText = &amp;quot;left&amp;quot;, anchorHoriz = &amp;quot;center&amp;quot;)
inst_text.setText(&amp;quot;&amp;quot;&amp;quot;
Which city has a larger population?
Select the city by pressing the F or J of the keyboard.

Click &amp;quot;Start&amp;quot; and work on the task.
&amp;quot;&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;教示を作っています。日本語だと少しめんどくさいので、英語で書いています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.setText()&lt;/code&gt;を使うと、&lt;code&gt;TextStim&lt;/code&gt;にテキストを埋め込むことができます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;startボタンを定義する123129行目&#34;&gt;Startボタンを定義する（123–129行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ボックスの線の太さ
box_line_width = 10

# 開始ボタンのボックスとテキスト
start_pos_y = -0.5 # Y軸座標
start_box = visual.Rect(win, width = 0.2, height = 0.2, pos = (0, start_pos_y), lineWidth = box_line_width)
start_text = visual.TextStim(win, text = &amp;quot;Start&amp;quot;, pos = (0, start_pos_y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Startボタンを定義しています。四角形は&lt;code&gt;visual.Rect()&lt;/code&gt;で作ります。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;その他のテキスト刺激や図形を定義する131157行目&#34;&gt;その他のテキスト刺激や図形を定義する（131–157行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 試行間で呈示するテキスト（テキストの中身は毎試行変えるので、後で定義する）
iti_text = visual.TextStim(win)
# ITIの長さ
iti_length = 2

# どちらの都市名を選んだかを何秒呈示するか
confirmation_length = 1
# 選んだ方の都市を囲うボックスを定義
city_box_width, city_box_height = 0.5, 0.2 # ボックスのサイズ
city_box_left = visual.Rect(win,
    width = city_box_width, height = city_box_height, pos = (-city_nudge_x, 0),
    lineColor = color_highlight, lineWidth = box_line_width
)
city_box_right = visual.Rect(win,
    width = city_box_width, height = city_box_height, pos = (city_nudge_x, 0),
    lineColor = color_highlight, lineWidth = box_line_width
)

# 正解不正解のテキスト
correct_text = visual.TextStim(win, text = &amp;quot;Correct!&amp;quot;)
wrong_text = visual.TextStim(win, text = &amp;quot;Wrong...&amp;quot;)
feedback_length = 1

# プロンプトのテキスト
hurry_text = visual.TextStim(win, text = &amp;quot;Hurry up!&amp;quot;, pos = (0, 0.8), color = color_highlight)
# time_limit秒経過したらプロンプトを出す
time_limit = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;その他のテキスト刺激や図形を定義しています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;ログファイルを設定する163164行目&#34;&gt;ログファイルを設定する（163–164行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ログファイルの設定
file_log = logging.LogFile(file_name_log, level = logging.EXP)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ログファイルを設定しています。実験中に何が起きたかをほぼ自動で記録してくれるので、設定しておくことをおすすめします。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;教示を呈示する170190行目&#34;&gt;教示を呈示する（170–190行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 教示（無限ループ）
while True:

    # Startにカーソルが載ってたら黄色に
    if start_box.contains(mouse):
        start_box.setLineColor(color_highlight)
        start_text.setColor(color_highlight)
    # 載ってなければ白に
    else:
        start_box.setLineColor(color_default)
        start_text.setColor(color_default)

    # 教示とボックスを描画
    inst_text.draw()
    start_box.draw()
    start_text.draw()
    win.flip()

    # 開始ボタンがクリックされたら無限ループを抜ける
    if mouse.isPressedIn(start_box):
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;教示を呈示しています。刺激を&lt;code&gt;draw()&lt;/code&gt;してから&lt;code&gt;win.flip()&lt;/code&gt;するのが基本です。&lt;/p&gt;
&lt;p&gt;Startボタンにカーソルが載ったら色を変えるようにしています。これを応用すると、マウスの位置を記録することができます。&lt;/p&gt;
&lt;p&gt;Startボタンがクリックされたらループを抜けます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;csvファイルの1行目に変数名を書き込む192199行目&#34;&gt;CSVファイルの1行目に変数名を書き込む（192–199行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# CSVファイルの先頭行に変数名を書き込む
with open(file_name_csv, &amp;quot;a&amp;quot;, encoding = &amp;quot;cp932&amp;quot;) as f:
    writer = csv.writer(f, lineterminator = &amp;quot;\n&amp;quot;)
    writer.writerow([
        &amp;quot;subj_id&amp;quot;, &amp;quot;trial&amp;quot;, &amp;quot;city_1&amp;quot;, &amp;quot;city_2&amp;quot;,
        &amp;quot;population_1&amp;quot;, &amp;quot;population_2&amp;quot;, &amp;quot;choice&amp;quot;,
        &amp;quot;correct_answer&amp;quot;, &amp;quot;result&amp;quot;, &amp;quot;rt&amp;quot;, &amp;quot;key&amp;quot;, &amp;quot;pos&amp;quot;
    ])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSVファイルに変数名を書き込んでいます。データを記録するときは、この書き方を真似するのがおすすめです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;カーソルを消して課題を始める205215行目&#34;&gt;カーソルを消して課題を始める（205–215行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# カーソルを消す
mouse.setVisible(False)

# 課題開始
for trial_index in range(len(city)):

    # 試行間のテキストを定義して描画
    iti_text.setText(str(trial_index + 1) + &amp;quot;/&amp;quot; + str(len(city)))
    iti_text.draw()
    win.flip()
    core.wait(iti_length)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;カーソルを消してから、試行のループに移っています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iti_text&lt;/code&gt;を定義し、呈示しています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core.wait(秒数)&lt;/code&gt;で、プログラムを指定時間止めることができます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;都市名を呈示217244行目&#34;&gt;都市名を呈示（217–244行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 刺激テキストをセット
    city_1 = city[&amp;quot;city_1&amp;quot;][trial_order[trial_index]]
    city_2 = city[&amp;quot;city_2&amp;quot;][trial_order[trial_index]]
    city_1_text.setText(city_1)
    city_2_text.setText(city_2)

    # ついでに人口と正解も記録しておく
    population_1 = city[&amp;quot;population_1&amp;quot;][trial_order[trial_index]]
    population_2 = city[&amp;quot;population_2&amp;quot;][trial_order[trial_index]]
    if population_1 &amp;gt; population_2:
        answer = &amp;quot;city_1&amp;quot;
    else:
        answer = &amp;quot;city_2&amp;quot;

    # 刺激の位置のカウンターバランス
    if city_pos[trial_index] == &amp;quot;one_two&amp;quot;:
        city_1_text.setPos((-city_nudge_x, 0))
        city_2_text.setPos((city_nudge_x, 0))
    else:
        city_1_text.setPos((city_nudge_x, 0))
        city_2_text.setPos((-city_nudge_x, 0))

    # 刺激を描画
    city_1_text.draw()
    city_2_text.draw()
    key_left_text.draw()
    key_right_text.draw()
    win.flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都市名刺激を定義・描画したり、課題に関連するデータを記録したりしています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.setPos()&lt;/code&gt;を使うと、刺激の呈示位置を変更することができます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;開始時間を記録しキーボードをリセット246251行目&#34;&gt;開始時間を記録し、キーボードをリセット（246–251行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 回答を待ち始めた時間をresp_onsetとして記録
    resp_onset = core.Clock()

    # キー押しをリセット
    kb.getKeys([key_left, key_right], waitRelease = False)
    kb.clock.reset()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刺激呈示の開始時間を記録し、キーボードをリセットしています。&lt;/p&gt;
&lt;p&gt;ここでキーボードをリセットしないと、次の試行にキー押しが引き継がれてしまいます。忘れないようにしましょう。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;回答を待つ253318行目&#34;&gt;回答を待つ（253–318行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 回答を待つ（無限ループ）
    while True:

        # FかJのキー押しを待つ
        key_pressed = kb.getKeys(keyList = [key_left, key_right], waitRelease = False)

        # もしFかJが押されたら
        if len(key_pressed) &amp;gt; 0:

            # 反応時間を記録
            rt = key_pressed[0].rt

            # どっちのキーを押したかをkeyとして記録
            # カウンターバランスに応じて、どっちの都市を選んだかをchoiceとして記録
            if key_pressed[0].name == key_left:
                key = key_left
                if city_pos[trial_index] == &amp;quot;one_two&amp;quot;:
                    choice = &amp;quot;city_1&amp;quot;
                else:
                    choice = &amp;quot;city_2&amp;quot;
            else:
                key = key_right
                if city_pos[trial_index] == &amp;quot;one_two&amp;quot;:
                    choice = &amp;quot;city_2&amp;quot;
                else:
                    choice = &amp;quot;city_1&amp;quot;

            # 結果を記録
            if choice == answer:
                result = &amp;quot;correct&amp;quot;
            else:
                result = &amp;quot;wrong&amp;quot;

            # 選んだ方の都市名を黄色にする
            if choice == &amp;quot;city_1&amp;quot;:
                city_1_text.setColor(color_highlight)
            else:
                city_2_text.setColor(color_highlight)

            # 選んだ方の都市を囲う四角を描画
            if key == key_left:
                city_box_left.draw()
            else:
                city_box_right.draw()

            # その他の刺激も描画して、1秒間呈示
            city_1_text.draw()
            city_2_text.draw()
            key_left_text.draw()
            key_right_text.draw()
            win.flip()
            core.wait(confirmation_length)

            # 刺激の色をリセットし、無限ループから抜ける
            city_1_text.setColor(color_default)
            city_2_text.setColor(color_default)
            break

        # ※time_limitを過ぎたらプロンプトを出す
        if resp_onset.getTime() &amp;gt; time_limit:
            city_1_text.draw()
            city_2_text.draw()
            key_left_text.draw()
            key_right_text.draw()
            hurry_text.draw()
            win.flip()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回答を待ちます。反応があったらテキストを黄色にし、四角で囲みます。5秒経過したらプロンプトを出すようにしています。&lt;/p&gt;
&lt;p&gt;コードは長めですが、ここでのキー押し判定や条件分岐は汎用性が高いです。というか、ほとんどの実験はこういう（長い）パーツの組み合わせからできています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;フィードバックをし各試行のデータを記録320338行目&#34;&gt;フィードバックをし、各試行のデータを記録（320–338行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 正解不正解のフィードバックを呈示
    if result == &amp;quot;correct&amp;quot;:
        correct_text.draw()
    else:
        wrong_text.draw()
    win.flip()
    core.wait(feedback_length)

    # CSVファイルにデータを記録
    with open(file_name_csv, &amp;quot;a&amp;quot;, encoding = &amp;quot;cp932&amp;quot;) as f:
        writer = csv.writer(f, lineterminator = &amp;quot;\n&amp;quot;)
        writer.writerow([
            subj_id, trial_index, city_1, city_2,
            population_1, population_2, choice,
            answer, result, rt, key, city_pos[trial_index]
        ])

    # ログファイルを保存
    logging.flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正解不正解のフィードバックを出してから、データを記録しています。&lt;/p&gt;
&lt;p&gt;なお、ここでは日本語（都市名）を記録しているので、&lt;code&gt;encoding = &amp;quot;cp932&amp;quot;&lt;/code&gt;としていますが、ふつうは要らないです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;実験終了344355行目&#34;&gt;実験終了（344–355行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 終わりの画面を定義
finish_text = visual.TextStim(win)
finish_text.setText(&amp;quot;&amp;quot;&amp;quot;
Finish! Thanks!
&amp;quot;&amp;quot;&amp;quot;)

# 3秒呈示してから実験終了
finish_text.draw()
win.flip()
core.wait(3)
win.close()
core.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;終了のメッセージを出して、3秒経過したら実験が終わります。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;
&lt;p&gt;このチュートリアルでは割愛した内容もあります。その中で最も重要なものは「関数の自作」です。関数の自作については、&lt;a href=&#34;https://qiita.com/snishym/items/8b52db0d901cf5744463&#34; title=&#34;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&lt;/a&gt;の第7回を読んでください。&lt;/p&gt;
&lt;p&gt;おそらく、このチュートリアルはわかりにくいです。しかし、ここに載っている機能を使えば、大体の社会心理学実験や意思決定実験のたたき台を作ることはできると思います&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。かなり駆け足でしたが、このチュートリアルが誰かの役に立てば幸いです。&lt;/p&gt;
&lt;br&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;本当は「いきなり」じゃない、すなわち、ある程度想定できたことなんだけど、なかなか準備できないものです。私もそうでした。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;試行の順序がシャッフルされているので、本来は呈示位置をシャッフルする必要はないです。一応参考のために書いています。 &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;そもそも、この（不親切な）説明に付いて来ようとしている時点でかなりモチベーションがあるはずです。プラスアルファで公式のリファレンスを読めば、実用に耐える実験プログラムをすぐに書けるようになると思います。 &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
  </channel>
</rss>
