<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kiri Kuroda</title>
    <link>https://kirikuroda.github.io/</link>
      <atom:link href="https://kirikuroda.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Kiri Kuroda</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>ja-jp</language><lastBuildDate>Sat, 05 Sep 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://kirikuroda.github.io/images/icon_hu219fcabef873e532f569b4eca90c980a_20624_512x512_fill_lanczos_center_2.png</url>
      <title>Kiri Kuroda</title>
      <link>https://kirikuroda.github.io/</link>
    </image>
    
    <item>
      <title>認知モデルのパラメタを最尤推定する</title>
      <link>https://kirikuroda.github.io/post/2020/09/05/mle-delay-discounting/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/09/05/mle-delay-discounting/</guid>
      <description>

&lt;div id=&#34;TOC&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#はじめに&#34;&gt;はじめに&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#背景&#34;&gt;背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#このページの概要&#34;&gt;このページの概要&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#遅延割引のモデルを解説&#34;&gt;遅延割引のモデルを解説&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#遅延割引課題とは&#34;&gt;遅延割引課題とは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#遅延割引のモデル&#34;&gt;遅延割引のモデル&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#肢選択のモデル&#34;&gt;2肢選択のモデル&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#実際に遅延割引パラメタを推定する&#34;&gt;実際に遅延割引パラメタを推定する&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#実験データを作ってみる&#34;&gt;実験データを作ってみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#素朴にパラメタを推定してみる&#34;&gt;素朴にパラメタを推定してみる&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#尤度を計算する&#34;&gt;尤度を計算する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#対数尤度を計算する&#34;&gt;対数尤度を計算する&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#optimでパラメタを推定する&#34;&gt;optimでパラメタを推定する&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#おわりに&#34;&gt;おわりに&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;

&lt;div id=&#34;はじめに&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;はじめに&lt;/h1&gt;
&lt;div id=&#34;背景&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;背景&lt;/h2&gt;
&lt;p&gt;いま一部の心理学領域で、認知モデルを立ててそのパラメタを推定する、あるいは、複数のモデルの良さを比較する、というデータ分析がスタンダードになりつつあります。また、その分析手法として、主にStanを使ったベイズ推定が取り上げられるようになっています。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;しかし、一体どれだけの人（特に学部生）がベイズ推定についていけているでしょうか？&lt;/strong&gt;　実際には、「ベイズ推定どころか最尤推定って何？　具体的にはどう計算するの？　どういうコードを書けばいいの？　そもそも認知モデルって何？」となってしまう&lt;a href=&#34;#fn1&#34; class=&#34;footnote-ref&#34; id=&#34;fnref1&#34;&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;場合が多いのでは？、というのが私の肌感覚です。&lt;/p&gt;
&lt;p&gt;そういう「置いてけぼり感」を覚えてしまうことに無理はないです。現状、心理学（特に社会心理学）の授業で、認知モデルに関するトレーニングを受ける機会は少ないからです&lt;a href=&#34;#fn2&#34; class=&#34;footnote-ref&#34; id=&#34;fnref2&#34;&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;このページの概要&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;このページの概要&lt;/h2&gt;
&lt;p&gt;そこでこのページでは、&lt;strong&gt;遅延割引課題&lt;/strong&gt;を例として、認知モデルのパラメタをどうやって&lt;strong&gt;最尤推定&lt;/strong&gt;するかを、具体的に見ていくことにします。推定にはRを使います。&lt;/p&gt;
&lt;p&gt;なお、この課題については、『&lt;a href=&#34;http://www.asakura.co.jp/books/isbn/978-4-254-12842-0/&#34; title=&#34;社会科学のためのベイズ統計モデリング&#34;&gt;社会科学のためのベイズ統計モデリング&lt;/a&gt;』の第9章を参考にしています。より詳しく知りたい方は、そちらを読んでください。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;遅延割引のモデルを解説&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;遅延割引のモデルを解説&lt;/h1&gt;
&lt;div id=&#34;遅延割引課題とは&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;遅延割引課題とは&lt;/h2&gt;
&lt;p&gt;遅延割引課題とは、「&lt;strong&gt;いますぐに小さい金額をもらうか、だいぶ先になっちゃうけどより大きい金額をもらうか&lt;/strong&gt;」のどちらかを選ぶという課題です。&lt;/p&gt;
&lt;p&gt;ここでは、「&lt;strong&gt;いますぐにr円をもらうか、n日後に50000円をもらうか&lt;/strong&gt;」のどちらかを選ぶことになったとします。もっと具体的に考えるために、以下の2つの例を考えてみましょう。&lt;/p&gt;
&lt;p&gt;まず、「&lt;strong&gt;いますぐに5000円をもらうか、30日後に50000円をもらうか&lt;/strong&gt;」と聞かれたら、どっちを選びますか？　おそらく、多くの人は「&lt;strong&gt;30日後に50000円&lt;/strong&gt;」を選ぶのではないでしょうか。&lt;/p&gt;
&lt;p&gt;次に、「&lt;strong&gt;いますぐに45000円をもらうか、720日後に50000円をもらうか&lt;/strong&gt;」と聞かれたら、どっちを選びますか？　ここでは逆に、「&lt;strong&gt;いますぐに45000円&lt;/strong&gt;」を選ぶ人が多いと思います。&lt;/p&gt;
&lt;p&gt;イメージはつきましたか？　この例からわかるように、遅延割引課題は「&lt;strong&gt;長期的利益のために、人々が目先の利益をどれくらい我慢できるか&lt;/strong&gt;」を測定するものです。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;遅延割引のモデル&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;遅延割引のモデル&lt;/h2&gt;
&lt;p&gt;さて、「&lt;strong&gt;人が長期的な利益をどれくらい良いと感じるか&lt;/strong&gt;」は、以下の式（モデル）で表現できるとされています&lt;a href=&#34;#fn3&#34; class=&#34;footnote-ref&#34; id=&#34;fnref3&#34;&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
U(A,t) = U(A)\frac{1}{1+kt}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;それぞれの記号は以下の内容を表しています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;：金額。ここでは50000円だと考えてください&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;：何日後に&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;（すなわち50000円）をもらえるか&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A, t)\)&lt;/span&gt;：&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;（50000円）をもらった場合の「嬉しさ」&lt;a href=&#34;#fn4&#34; class=&#34;footnote-ref&#34; id=&#34;fnref4&#34;&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A)\)&lt;/span&gt;：いますぐに&lt;span class=&#34;math inline&#34;&gt;\(A\)&lt;/span&gt;（50000円）をもらった場合の嬉しさ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;：&lt;strong&gt;遅延割引パラメタ&lt;/strong&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;では、この&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;（遅延割引パラメタ）とは具体的にどういうものなのでしょうか？　それを理解するために、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;をいじってみましょう。&lt;/p&gt;
&lt;p&gt;Figure 1の横軸は「t日」、縦軸は「そのとき50000円をもらったときの嬉しさ（すなわち、&lt;span class=&#34;math inline&#34;&gt;\(U(A,t)\)&lt;/span&gt;）」を表しています。ここでは、&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日を0〜30で変化させ、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;を0から0.5まで0.05刻みで変化させています。&lt;/p&gt;
&lt;p&gt;この図からどういうことが読み取れるでしょうか？&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;library(tidyverse)

expand_grid(t = 0:30, k = seq(0, 0.5, 0.05)) %&amp;gt;%
  mutate(u = 50000 * (1 / (1 + k * t))) %&amp;gt;%
  ggplot(aes(x = t, y = u, group = k, color = k)) +
  geom_line() +
  scale_color_viridis_c() +
  labs(x = &amp;quot;t（日）&amp;quot;, y = &amp;quot;t日後に50000円もらったときの嬉しさ&amp;quot;) +
  theme_minimal(base_family = &amp;quot;ヒラギノ角ゴシック W3&amp;quot;) +
  theme(axis.text = element_text(color = &amp;quot;#333333&amp;quot;))&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:setup&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://kirikuroda.github.io/ja/post/2020-09-05-delay-discounting/index_files/figure-html/setup-1.png&#34; alt=&#34;t日後に50000円もらったときの嬉しさ&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 1: t日後に50000円もらったときの嬉しさ
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;まず、&lt;span class=&#34;math inline&#34;&gt;\(t = 0\)&lt;/span&gt;のとき、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;がどんな値であれ、縦軸（50000円もらったときの嬉しさ）は50000円です。&lt;span class=&#34;math inline&#34;&gt;\(t = 0\)&lt;/span&gt;は「今すぐ」と同じだからです。&lt;/p&gt;
&lt;p&gt;次に、&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;が大きくなるほど、「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円」の嬉しさは低くなっています。&lt;/p&gt;
&lt;p&gt;また、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が大きくなるほど（線が明るい色になるほど）、「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円」の嬉しさは低くなっています。これを引っ張って考えると、「&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が大きい人ほど、今すぐの利益に目がくらんでしまいがち&lt;/strong&gt;」ということになります&lt;a href=&#34;#fn5&#34; class=&#34;footnote-ref&#34; id=&#34;fnref5&#34;&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;肢選択のモデル&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;2肢選択のモデル&lt;/h2&gt;
&lt;p&gt;では次に「2つの選択肢（目先の利益 vs. 長期的な利益）をどうやって選ぶか」のモデルを考えてみましょう。&lt;/p&gt;
&lt;p&gt;ここでは「今すぐ5000円をもらうか、1ヶ月後に50000円をもらうか」を選ぶ状況を例とします。私たちは多くの場合、「1ヶ月後に50000円」を選ぶでしょう。&lt;/p&gt;
&lt;p&gt;しかし、人間というものは、そこまで完璧ではありません。もし「ねえ、今すぐ5000円あげるけど、欲しいよね？」と100回も聞かれたら、何回かは誘惑にかられて「今すぐ5000円」を選んでしまうかもしれません。&lt;/p&gt;
&lt;p&gt;このような現象を表すため、よくロジスティック関数&lt;a href=&#34;#fn6&#34; class=&#34;footnote-ref&#34; id=&#34;fnref6&#34;&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;というものが用いられます。遅延割引課題の例では、以下のように書くことができます。&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[
P_{d} = \frac{1}{1+\exp(-\beta[U(A^{d})-U(A^{s})])}
\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;記号の意味は以下のとおりです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(P_{d}\)&lt;/span&gt;：遅延報酬（&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円）を選ぶ確率（0〜1の値）&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A^{d})\)&lt;/span&gt;：遅延報酬をもらった時の嬉しさ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A^{s})\)&lt;/span&gt;：即時報酬（今すぐの報酬）をもらった時の嬉しさ&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;：逆温度パラメタ（&lt;strong&gt;嬉しさの差分&lt;/strong&gt;にどれくらい敏感に反応するか）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;詳しくは「ロジスティック関数」などで調べてほしいのですが、この式で大事なのは以下の2点です。&lt;/p&gt;
&lt;ol style=&#34;list-style-type: decimal&#34;&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(U(A^{d})-U(A^{s})\)&lt;/span&gt;が大きくなるほど&lt;span class=&#34;math inline&#34;&gt;\(P_{d}\)&lt;/span&gt;も大きくなる。&lt;/strong&gt;すなわち、遅延報酬が即時報酬よりも魅力的であるほど、遅延報酬を選ぶ確率が高くなるということです。裏を返すと、即時報酬のほうが魅力的であるほど、遅延報酬を選ぶ確率が低くなる（つまり、即時報酬を選ぶ確率が高くなる）ということも表しています。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;が大きいほど、「嬉しさ」の差分に強く反応する。&lt;/strong&gt;つまり、&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;が大きい場合、嬉しさの大きい方を忠実に選ぶようになるということです。逆に&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;が0に近いほど、どちらを選ぶかはランダムに近づく（「嬉しさ」の影響力が弱くなり、選択肢をでたらめに選ぶようになる）ということも表しています。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;さて、遅延割引課題を用いた研究で知りたいのは、&lt;strong&gt;ある人（参加者）がどれくらい目先の利益に目がくらみがちか&lt;/strong&gt;、そして、&lt;strong&gt;ある人（参加者）がどれくらい「嬉しさ」の差分に強く反応するか&lt;/strong&gt;ということです。これを言い換えると、&lt;strong&gt;ある人がどれくらいの&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;（遅延割引パラメタ）を持っているか&lt;/strong&gt;、&lt;strong&gt;ある人がどれくらいの&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;（逆温度パラメタ）を持っているか&lt;/strong&gt;ということになります。&lt;/p&gt;
&lt;p&gt;認知モデルのパラメタを推定するというのは、まさに「ある人がどれくらいのパラメタ（認知的な傾向）を持っているか」を探ろうとする分析を意味しています。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;実際に遅延割引パラメタを推定する&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;実際に遅延割引パラメタを推定する&lt;/h1&gt;
&lt;div id=&#34;実験データを作ってみる&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;実験データを作ってみる&lt;/h2&gt;
&lt;p&gt;ここで具体的な分析方法を説明したいのですが、まだ手元にはデータがありません。&lt;/p&gt;
&lt;p&gt;そこで、ある1人の参加者が50回の遅延割引課題に取り組んだと仮定します。具体的には「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円をもらうか、今すぐ&lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;円をもらうか」を選んだとしましょう。各回で、日数&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;は｛30, 90, 180, 360, 720｝のいずれか、今すぐの報酬&lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;は｛5000, 1000, …, 50000｝のいずれかとします（5通り×10通りなので50回の課題、ということです）。では、下のコードのように仮想的なデータを作り、&lt;code&gt;data&lt;/code&gt;というデータフレームとして保存してみましょう&lt;a href=&#34;#fn7&#34; class=&#34;footnote-ref&#34; id=&#34;fnref7&#34;&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)
data &amp;lt;- expand_grid(
  t = c(30, 90, 180, 360, 720),
  r = seq(5000, 50000, 5000)
  ) %&amp;gt;%
  mutate(
    u_delay = 50000 * (1 / (1 + 0.01 * t)),
    p = 1 / (1 + exp(-0.00005 * (u_delay - r)))
  ) %&amp;gt;%
  group_by(row_number()) %&amp;gt;%
  mutate(choice = rbinom(1, 1, p))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;では、この参加者は遅延報酬（「&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;日後に50000円」）を何回選んだのでしょうか？　遅延報酬を選んだ場合、&lt;code&gt;data&lt;/code&gt;の&lt;code&gt;choice&lt;/code&gt;という変数は&lt;code&gt;1&lt;/code&gt;になっています。逆に即時報酬（「すぐに&lt;span class=&#34;math inline&#34;&gt;\(r\)&lt;/span&gt;円」）を選んだ場合、&lt;code&gt;choice&lt;/code&gt;は&lt;code&gt;0&lt;/code&gt;です。&lt;/p&gt;
&lt;p&gt;参加者の選択を下にプロットしてみました。横軸は遅延日数&lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;、縦軸は選択（0か1）、各パネルの上の数字は即時報酬の金額を表しています。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;data %&amp;gt;%
  ggplot(aes(x = t, y = choice)) +
  geom_point() +
  scale_y_continuous(breaks = c(0, 1)) +
  facet_wrap(~r)&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;figure&#34;&gt;&lt;span id=&#34;fig:unnamed-chunk-2&#34;&gt;&lt;/span&gt;
&lt;img src=&#34;https://kirikuroda.github.io/ja/post/2020-09-05-delay-discounting/index_files/figure-html/unnamed-chunk-2-1.png&#34; alt=&#34;ある参加者がどれくらい遅延報酬を選んだか&#34; width=&#34;672&#34; /&gt;
&lt;p class=&#34;caption&#34;&gt;
Figure 2: ある参加者がどれくらい遅延報酬を選んだか
&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;素朴にパラメタを推定してみる&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;素朴にパラメタを推定してみる&lt;/h2&gt;
&lt;p&gt;さて、どのようにパラメタを推定すればよいのでしょうか？　まず、素朴なアイデアから出発してみます。&lt;/p&gt;
&lt;p&gt;たとえば、「なんとなくだけど、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;は0.1で、&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;は0.0001じゃね？」と考えたとしましょう。このとき、これらのパラメタの値はどれくらいふさわしいでしょうか？　また、そのふさわしさはどのように評価（計算）されるべきでしょうか？&lt;/p&gt;
&lt;p&gt;とりあえず、上で説明した2つのモデルに代入してみましょう。ここでは、「今すぐ5000円」と「30日後に50000円」を比べた場合を考えてみます。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t &amp;lt;- 30
k &amp;lt;- 0.1
beta &amp;lt;- 0.0001

# u_delay：遅延報酬のU
u_delay &amp;lt;- 50000 * (1 / (1 + 0.1 * t))

# 30日後に50000円を選ぶ確率
p &amp;lt;- 1 / (1 + exp(-beta * (u_delay - 5000)))

print(p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 0.6791787&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;さて、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;としたとき、遅延報酬を選ぶ確率は0.6791787になりました。では、実際のデータはどうだったでしょうか？ つまり、「今すぐ5000円 vs. 30日後に50000円」のとき、どっちを選んでいたでしょうか？&lt;/p&gt;
&lt;p&gt;Figure 2を見ると、参加者が遅延報酬（30日後に50000円）を選んでいたということがわかります。では、上の計算で出てきた「遅延報酬を選ぶ確率は0.6791787」と「参加者が実際に遅延報酬を選んでいたという事実」はどのように関係しているのでしょうか。&lt;/p&gt;
&lt;p&gt;「遅延報酬を選ぶ確率」というのは、「『遅延報酬を選ぶ』という結果が得られる確率」と言い換えることができます。この「『遅延報酬を選ぶ』という結果が得られる確率」は、パラメタ&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;と&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;を色々な値にすれば、それに応じて様々な値に変動します。&lt;/p&gt;
&lt;p&gt;ここで、「参加者が実際に遅延報酬を選んで」いたとしましょう。このとき、適当にパラメタを代入して、「『遅延報酬を選ぶ』という結果が得られる確率」が高かった場合、それは何を意味しているでしょうか。&lt;/p&gt;
&lt;p&gt;日常言語で表すと、「参加者は遅延報酬を選んでいた。適当にパラメタを代入したら、遅延報酬を選ぶ確率は高いらしい。これって実際のデータと結構近いじゃん」ということになります。さらにこれを引っ張ると、「結構近いんだから、このパラメタって、もしかして良い線行ってるんじゃね？」となります。逆に、予測が外れた場合は、そのパラメタはあまりよろしくないと言えます。&lt;/p&gt;
&lt;p&gt;つまり、「ある結果が得られている。そこで、適当にパラメタを設定したら、その結果が得られる確率も高いようだ。だったら、そのパラメタは『ふさわしい』んじゃないか」ということです。このようなパラメタの「ふさわしさ」（&lt;strong&gt;パラメタを設定したとき、手元にあるデータが得られる確率&lt;/strong&gt;）を真面目に言うと「尤度」になります。また、尤度をもとにパラメタを推定する方法を最尤推定と言います。&lt;/p&gt;
&lt;p&gt;この例では、「いま、参加者が遅延報酬を選んだことがわかっている。そこで、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;としたとき、遅延報酬を選ぶ確率は0.6791787だった」ということになります。すなわち、尤度は0.6791787です&lt;a href=&#34;#fn8&#34; class=&#34;footnote-ref&#34; id=&#34;fnref8&#34;&gt;&lt;sup&gt;8&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;尤度を計算する&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;尤度を計算する&lt;/h2&gt;
&lt;p&gt;では、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;とし、全50回の尤度を計算してみましょう。まず、以下のコードを実行します。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;t &amp;lt;- 30
k &amp;lt;- 0.1
beta &amp;lt;- 0.0001

data %&amp;gt;%
  # 遅延報酬のUと、遅延報酬を選ぶ確率pを計算
  mutate(
    u_delay = 50000 * (1 / (1 + k * t)),
    p = 1 / (1 + exp(-beta * (u_delay - r)))
  ) %&amp;gt;%
  # 遅延報酬を選ぶ確率pを抽出
  pull(p)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.679178699 0.562176501 0.437823499 0.320821301 0.222700139 0.148047198
##  [7] 0.095349465 0.060086650 0.037326887 0.022977370 0.500000000 0.377540669
## [13] 0.268941421 0.182425524 0.119202922 0.075858180 0.047425873 0.029312231
## [19] 0.017986210 0.010986943 0.441064710 0.323695074 0.224986141 0.149714490
## [25] 0.096490497 0.060834074 0.037802587 0.023274618 0.014247244 0.008690106
## [31] 0.409782432 0.296323939 0.203450772 0.134137019 0.085891464 0.053918000
## [37] 0.033411753 0.020535219 0.012556698 0.007653837 0.393766567 0.282619107
## [43] 0.192864008 0.126583888 0.080801479 0.050617863 0.031325176 0.019236783
## [49] 0.011756686 0.007163930&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;上に表示されているのは、遅延報酬を選ぶ確率&lt;span class=&#34;math inline&#34;&gt;\(p\)&lt;/span&gt;です。&lt;/p&gt;
&lt;p&gt;しかし、これをそのまま最尤推定に使うことはできません。なぜなら、尤度とは「あるパラメタを設定したときに、&lt;strong&gt;手元にあるデータ&lt;/strong&gt;が得られる確率」だからです。実験では、参加者が即時報酬を選ぶ場合も当然あるので、その場合は「即時報酬を選ぶ確率」を使わないといけません。したがって、各回の尤度（&lt;code&gt;likelihood&lt;/code&gt;）は以下のようになります。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;likelihood &amp;lt;- data %&amp;gt;%
  # 遅延報酬のUと、遅延報酬を選ぶ確率pを計算
  # さらに、参加者の選択に応じて条件分岐をして尤度を計算
  mutate(
    u_delay = 50000 * (1 / (1 + k * t)),
    p = 1 / (1 + exp(-beta * (u_delay - r))),
    likelihood = if_else(choice == 1, p, 1 - p)
  ) %&amp;gt;%
  pull(likelihood)

likelihood&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;##  [1] 0.67917870 0.56217650 0.43782350 0.67917870 0.22270014 0.85195280
##  [7] 0.90465054 0.06008665 0.03732689 0.97702263 0.50000000 0.37754067
## [13] 0.73105858 0.18242552 0.88079708 0.92414182 0.04742587 0.02931223
## [19] 0.98201379 0.01098694 0.55893529 0.32369507 0.77501386 0.85028551
## [25] 0.90350950 0.93916593 0.96219741 0.97672538 0.01424724 0.99130989
## [31] 0.40978243 0.70367606 0.79654923 0.86586298 0.08589146 0.94608200
## [37] 0.03341175 0.97946478 0.98744330 0.99234616 0.60623343 0.28261911
## [43] 0.19286401 0.87341611 0.91919852 0.05061786 0.96867482 0.98076322
## [49] 0.98824331 0.99283607&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;対数尤度を計算する&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;対数尤度を計算する&lt;/h2&gt;
&lt;p&gt;では、ここで全50回の尤度を1つの指標にまとめたいと思います（まとめたいですよね？）。このとき、直観的には尤度を足し算すれば良いんじゃないか、と思うかもしれませんが、それは間違いです。&lt;/p&gt;
&lt;p&gt;正解は「かけ算」です。詳しい説明は適宜教科書を読むなり、ググってもらえるとありがたいです&lt;a href=&#34;#fn9&#34; class=&#34;footnote-ref&#34; id=&#34;fnref9&#34;&gt;&lt;sup&gt;9&lt;/sup&gt;&lt;/a&gt;。簡単な例で言えば、「3回連続でじゃんけんに勝つ確率は？」と聞かれたとき、「1/3を3回足して1」ではなく、「1/3を3回かけ算して1/27」と答えるのが正解になるのと同じ理屈です。&lt;/p&gt;
&lt;p&gt;では、上で求めた尤度を全部かけ算してみましょう。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# prod()で、要素を全部かけあわせることになる
prod(likelihood)&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] 1.143327e-20&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;これは0.00000000000000000001143327を表しています。&lt;/p&gt;
&lt;p&gt;ちっさ！って思うのではないでしょうか。と同時に、「やっぱ、パソコンはこんな細かい計算できて偉いなあ」と思う人がいるかもしれません。&lt;/p&gt;
&lt;p&gt;しかし、残念ながらそれは間違いです。あまりに数字が小さいと、パソコンの計算にも誤差が生じてしまいます&lt;a href=&#34;#fn10&#34; class=&#34;footnote-ref&#34; id=&#34;fnref10&#34;&gt;&lt;sup&gt;10&lt;/sup&gt;&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;これを防ぐため、尤度を計算するときは、&lt;strong&gt;対数を取る&lt;/strong&gt;というのが決まりになっています。なぜなら、かけ算の対数を取ると足し算になるという便利な性質があるからです&lt;a href=&#34;#fn11&#34; class=&#34;footnote-ref&#34; id=&#34;fnref11&#34;&gt;&lt;sup&gt;11&lt;/sup&gt;&lt;/a&gt;。対数を取って求めた尤度を「対数尤度」と言います。&lt;/p&gt;
&lt;p&gt;また、対数は単調増加関数なので、「尤度の積が大きい（もっともらしい）場合は、その対数も大きくなる」という関係が成り立ちます。対数、便利です。&lt;/p&gt;
&lt;p&gt;では、対数尤度を計算し、全部を足し算してみましょう。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;sum(log(likelihood))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -45.91776&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;確認のため、尤度を全部掛け算したやつの対数を取ってみましょう。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;log(prod(likelihood))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## [1] -45.91776&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;ちゃんと2つが一致しました。ただし、データの数が多いほどかけ算の誤差は大きくなるので、やはり対数を取ってから足し算をするようにしましょう。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;optimでパラメタを推定する&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;optimでパラメタを推定する&lt;/h2&gt;
&lt;p&gt;さて、&lt;span class=&#34;math inline&#34;&gt;\(k = 0.1\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta = 0.0001\)&lt;/span&gt;としたときの50回の対数尤度は-45.91776になりました。&lt;/p&gt;
&lt;p&gt;で？　それが何？&lt;/p&gt;
&lt;p&gt;そうです。これだけでは、まだ何も言えていません。他のパラメタの候補も調べないと、どのパラメタが良さそうかはわかりません。&lt;/p&gt;
&lt;p&gt;では、どうすればよいでしょうか？　素朴に考えたら、有り得そうな&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;や&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;を片っ端から代入して対数尤度を計算する、というのが良さそうです。しかし、そんな時間は私たちにはありません。&lt;/p&gt;
&lt;p&gt;そこで使うのが、Rの最適化関数&lt;code&gt;optim&lt;/code&gt;です。最適化関数とは、ある関数の最大値／最小値を求めるための道具だと考えてください。&lt;/p&gt;
&lt;p&gt;いま私たちがやりたいのは、対数尤度が最も大きくなりそうなパラメタ&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;と&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;の組み合わせを調べるということです。つまり、&lt;code&gt;optim&lt;/code&gt;を使って、対数尤度（関数）が最大化されるような&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;と&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;を見つければ目的達成ということになります。&lt;/p&gt;
&lt;p&gt;では、具体的な書き方を説明します。まず、対数尤度関数（&lt;code&gt;ll_delay&lt;/code&gt;）を自分で定義します。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;# 関数を定義する
ll_delay &amp;lt;- function(param, data) {
  
  # param[1]はk、param[2]はbetaを表している
  # dataは参加者のデータフレームそのものを表している
  
  data %&amp;gt;%
    # 毎回の対数尤度を計算する
    mutate(
      u_delay = 50000 * (1 / (1 + param[1] * t)),
      p = 1 / (1 + exp(-param[2] * (u_delay - r))),
      likelihood = if_else(choice == 1, p, 1 - p),
      ll = log(likelihood)
    ) %&amp;gt;%
    # 最後に全部足し合わせる
    pull(ll) %&amp;gt;%
    sum()
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;これを&lt;code&gt;optim&lt;/code&gt;に突っ込みます。&lt;code&gt;par&lt;/code&gt;には推定したいパラメタの初期値、&lt;code&gt;fn&lt;/code&gt;には最適化したい関数を入れます。&lt;code&gt;control = list(fnscale = -1)&lt;/code&gt;とすると、関数の最大化が行われるようになります。その他の引数（この例では&lt;code&gt;data&lt;/code&gt;）では、&lt;code&gt;ll_delay&lt;/code&gt;にどんな引数を渡すかを指示してあげます。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;optim(par = c(0.1, 0.0001), fn = ll_delay, data = data, control = list(fnscale = -1))&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;## $par
## [1] 0.0132120062 0.0000423154
## 
## $value
## [1] -30.70504
## 
## $counts
## function gradient 
##       89       NA 
## 
## $convergence
## [1] 0
## 
## $message
## NULL&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;結果の&lt;code&gt;par&lt;/code&gt;が推定値を表しています。&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が0.0132120062、&lt;span class=&#34;math inline&#34;&gt;\(\beta\)&lt;/span&gt;は0.0000423154でした。&lt;/p&gt;
&lt;p&gt;では、正解は何だったのでしょうか？　正解は、データを作ったコードの中に隠れています。改めてコードを見てみましょう。&lt;/p&gt;
&lt;pre class=&#34;r&#34;&gt;&lt;code&gt;set.seed(1)
data &amp;lt;- expand_grid(
  t = c(30, 90, 180, 360, 720),
  r = seq(5000, 50000, 5000)
  ) %&amp;gt;%
  mutate(
    u_delay = 50000 * (1 / (1 + 0.01 * t)),
    p = 1 / (1 + exp(-0.00005 * (u_delay - r)))
  ) %&amp;gt;%
  group_by(row_number()) %&amp;gt;%
  mutate(choice = rbinom(1, 1, p))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;p&gt;最初は詳しく説明しませんでしたが、このコードでは、遅延割引と2肢選択のモデルを用いて、参加者の選択を仮想的に作っていました。とくに7行目と8行目を見てください。ここでは、参加者が&lt;span class=&#34;math inline&#34;&gt;\(k=0.01\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta=0.00005\)&lt;/span&gt;というパラメタを持つように設定しています。さて、推定結果は&lt;span class=&#34;math inline&#34;&gt;\(k=0.0132120062\)&lt;/span&gt;、&lt;span class=&#34;math inline&#34;&gt;\(\beta=0.0000423154\)&lt;/span&gt;でした。まあまあ良い線行ってるのではないでしょうか。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;おわりに&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;おわりに&lt;/h1&gt;
&lt;p&gt;ここまで、駆け足で認知パラメタの最尤推定を見てきました。もちろん、まだまだ説明していないトピックはありますが、まずはここらへんの内容を押さえておくのが良いかと思います。&lt;/p&gt;
&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;footnotes&#34;&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id=&#34;fn1&#34;&gt;&lt;p&gt;私が学部生の頃もそうでした。たとえば当時、とても偉い工学系の先生に「すみません、単回帰分析の最尤推定ってどうやるんですか？」みたいなことを聞いてたレベルです。ちなみに、単回帰分析の最尤推定は心理統計の教科書に載っているし、ググればすぐに出てくるような内容です。今思えばガチで恥ずかしいですが、「知らぬは一時の恥、聞かぬは一生の恥」です。そんな質問をしていた私ですら、いま一応なんとか生きてます。（以下、かなり脱線します。）わからないことがあったときにおすすめなのは、研究室や学科の先輩に質問することです。もちろんググっても良いのですが、先輩たちも同様の難所を乗り越えている場合が多いので、同じ目線で答えてくれる可能性が高いです。ただし、自分がふだん研究室に行かなかったり、先輩と全然コミュニケーションを取ったりしていないのに、「卒論締切間際に自分が困ったときにだけ質問する」みたいな姿勢は、傍から見ていると「それは虫が良すぎじゃね？」という感じがします。「&lt;strong&gt;ふだんから細かく&lt;/strong&gt;」質問する、世間話をしておく（※先輩の機嫌を取るということではないです）、ぐらいのことをやっておいたほうが、長期的には良いと思います。このトピックだけで記事を1つ書けそうです。&lt;a href=&#34;#fnref1&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn2&#34;&gt;&lt;p&gt;まあ、「授業が全てを教えてくれる」という期待・態度がそもそも間違っているという説はあります。結局のところ、研究スキルなんて、試行錯誤で無理くり獲得していくものなのかもしれません。&lt;a href=&#34;#fnref2&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn3&#34;&gt;&lt;p&gt;この式は、双曲割引（hyperbolic discounting）と言います。&lt;a href=&#34;#fnref3&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn4&#34;&gt;&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(U\)&lt;/span&gt;は「嬉しさ（Ureshisa）」の頭文字のUではなく、本当は「効用（Utility）」の頭文字を表しています。ここで「効用」とか書いちゃうと難しくなるので、「嬉しさ」にしています。&lt;a href=&#34;#fnref4&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn5&#34;&gt;&lt;p&gt;ちょっとジャンプがあるかもしれませんが、わからなかった場合はゆっくり考えてみてください。日常的な例（？）でいうと、&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が大きいほど、「健康診断のため1ヶ月後に3kg痩せるのは、今すぐに飴玉を1個食べるのと等しいと感じてしまう」ということです。このような人は「今すぐ飴玉2個あげるよ」と言われたら、飴玉2個を食べてしまう（目がくらんでしまう）ということになります。逆に&lt;span class=&#34;math inline&#34;&gt;\(k\)&lt;/span&gt;が小さいと、「1ヶ月後に3kg痩せるのは、今すぐ高級マカロン100個を食べるのと等しいと感じる」ということです。このような人は「今すぐマカロン1個あげるよ」と言われても、「そんな少ないマカロンをもらうぐらいなら、我慢して減量したほうがマシ」と返事をして、拒絶することになるでしょう。&lt;a href=&#34;#fnref5&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn6&#34;&gt;&lt;p&gt;ソフトマックス関数といったほうが厳密かもしれません。詳しくは『社会科学のためのベイズ統計モデリング』を読んだり、「ソフトマックス関数　ロジスティック関数」でググったりしてみてください。&lt;a href=&#34;#fnref6&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn7&#34;&gt;&lt;p&gt;とりあえずこのコードの意味を意味を理解する必要はないです。&lt;a href=&#34;#fnref7&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn8&#34;&gt;&lt;p&gt;正直、尤度や最尤推定については他にもっと優れた記事があると思うので、わからなければ適宜ググってもらえると嬉しいです。&lt;a href=&#34;#fnref8&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn9&#34;&gt;&lt;p&gt;「積事象」や「尤度」でググってみてください。&lt;a href=&#34;#fnref9&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn10&#34;&gt;&lt;p&gt;これをアンダーフローと言います。たとえば、Rのコンソールに&lt;code&gt;1e-1000&lt;/code&gt;とか打ってみて、どうなるかを見てみましょう。&lt;a href=&#34;#fnref10&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id=&#34;fn11&#34;&gt;&lt;p&gt;この説明は端折りますが、一応文系数学の範囲です。「尤度」でググると、この内容は必ず説明されているので、適宜調べてみてください。&lt;a href=&#34;#fnref11&#34; class=&#34;footnote-back&#34;&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>PsychoPy Coderチュートリアル</title>
      <link>https://kirikuroda.github.io/post/2020/09/02/psychopy-coder-tutorial/</link>
      <pubDate>Wed, 02 Sep 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/09/02/psychopy-coder-tutorial/</guid>
      <description>&lt;h2&gt;目次&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#はじめに&#34;&gt;はじめに&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#想定している読者層&#34;&gt;想定している読者層&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#既に公開されている優れたチュートリアル&#34;&gt;既に公開されている優れたチュートリアル&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#このチュートリアルの特色&#34;&gt;このチュートリアルの特色（？）&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#いきなりやってみるタイプのチュートリアル&#34;&gt;いきなりやってみるタイプのチュートリアル&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#いきなりセットアップ&#34;&gt;いきなりセットアップ&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#いきなり実験&#34;&gt;いきなり実験&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#実験の構造&#34;&gt;実験の構造&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#解説&#34;&gt;解説&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#ダイアログボックスを呈示する3846行目&#34;&gt;ダイアログボックスを呈示する（38–46行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#データファイルの名前を作る5267行目&#34;&gt;データファイルの名前を作る（52–67行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#クイズの項目を読み込む6970行目&#34;&gt;クイズの項目を読み込む（69–70行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#画面マウスキーボードを設定する7680行目&#34;&gt;画面、マウス、キーボードを設定する（76–80行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#都市名刺激を設定する86103行目&#34;&gt;都市名刺激を設定する（86–103行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#キーを設定する105112行目&#34;&gt;キーを設定する（105–112行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#教示を定義する114121行目&#34;&gt;教示を定義する（114–121行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#startボタンを定義する123129行目&#34;&gt;Startボタンを定義する（123–129行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#その他のテキスト刺激や図形を定義する131157行目&#34;&gt;その他のテキスト刺激や図形を定義する（131–157行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#ログファイルを設定する163164行目&#34;&gt;ログファイルを設定する（163–164行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#教示を呈示する170190行目&#34;&gt;教示を呈示する（170–190行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#csvファイルの1行目に変数名を書き込む192199行目&#34;&gt;CSVファイルの1行目に変数名を書き込む（192–199行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#カーソルを消して課題を始める205215行目&#34;&gt;カーソルを消して課題を始める（205–215行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#都市名を呈示217244行目&#34;&gt;都市名を呈示（217–244行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#開始時間を記録しキーボードをリセット246251行目&#34;&gt;開始時間を記録し、キーボードをリセット（246–251行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#回答を待つ253318行目&#34;&gt;回答を待つ（253–318行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#フィードバックをし各試行のデータを記録320338行目&#34;&gt;フィードバックをし、各試行のデータを記録（320–338行目）&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#実験終了344355行目&#34;&gt;実験終了（344–355行目）&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#おわりに&#34;&gt;おわりに&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;
&lt;h2 id=&#34;想定している読者層&#34;&gt;想定している読者層&lt;/h2&gt;
&lt;p&gt;このチュートリアルでは、以下のタイプの読者を想定しています：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;実験プログラムを書かなきゃいけなくなった心理学（特に社会心理学）系の学部生&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;卒論で（いきなり&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;）心理学実験のプログラムを書かなくちゃいけなくなった人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pythonの初心者本は一通り読んだけど、いざPsychoPyになるとよくわからない人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coderのどこから手を着ければいいかわからない人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;せっかくやるならBuilderじゃなくてCoderがいい、でもよくわからない、という人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CoderにDemosってやつがあるらしいけど、英語を読むことに苦手意識がある（あるいは、Demosの存在を知らない）という人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;時間がない人&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;既に公開されている優れたチュートリアル&#34;&gt;既に公開されている優れたチュートリアル&lt;/h2&gt;
&lt;p&gt;PsychoPyのCoderについては、既に優れたチュートリアルがいくつか公開されています（参照：
&lt;a href=&#34;https://qiita.com/snishym/items/8b52db0d901cf5744463&#34; title=&#34;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&lt;/a&gt;）。この「チュートリアルまとめ」、およびそこで紹介されているチュートリアルのいずれにおいても、Pythonの初歩から実験実施までが丁寧に解説されています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;このチュートリアルの特色&#34;&gt;このチュートリアルの特色（？）&lt;/h2&gt;
&lt;p&gt;このチュートリアルでは、Pythonの初歩の説明をすっ飛ばします。上で紹介した記事も含め、もっと優れた資料や書籍が山のようにあるからです。&lt;/p&gt;
&lt;p&gt;その代わりに、&lt;strong&gt;（社会）心理学の実験で割と使うと思われる機能&lt;/strong&gt;に絞って話を進めます。くわえてこのチュートリアルでは、&lt;strong&gt;最初から完成したコードを見て&lt;/strong&gt;、それを順に解説していくという方針を取ります。「該当するコードをコピペしていけば、自分の実験も書けるんじゃないか？」と思ってもらえることを狙っています。&lt;/p&gt;
&lt;p&gt;主に説明するのは以下の機能です：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ダイアログボックス&lt;/li&gt;
&lt;li&gt;データをCSVに記録&lt;/li&gt;
&lt;li&gt;テキスト刺激の呈示&lt;/li&gt;
&lt;li&gt;キー押しの検出&lt;/li&gt;
&lt;li&gt;クリックの検出&lt;/li&gt;
&lt;li&gt;反応時間の計測&lt;/li&gt;
&lt;li&gt;マウスやキー押しに応じて刺激の色を変える&lt;/li&gt;
&lt;li&gt;反応に応じたフィードバック　etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;p&gt;このチュートリアルの試みがどこまでうまくいくかわかりませんが、とりあえずセットアップしてみましょう。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;いきなりやってみるタイプのチュートリアル&#34;&gt;いきなりやってみるタイプのチュートリアル&lt;/h1&gt;
&lt;h2 id=&#34;いきなりセットアップ&#34;&gt;いきなりセットアップ&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;この記事では&lt;strong&gt;Mac&lt;/strong&gt;と&lt;strong&gt;PsychoPy 2020.2.3&lt;/strong&gt;を使ってます。&lt;strong&gt;この際なので、PsychoPyをアップデートしてください。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;
&lt;a href=&#34;https://github.com/kirikuroda/psychopy_coder_demo&#34; title=&#34;GitHubのページ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;https://github.com/kirikuroda/psychopy_coder_demo&lt;/a&gt;からファイルをダウンロードして、PCの適当な場所に保存してください。&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;いきなり実験&#34;&gt;いきなり実験&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;先ほどダウンロードした&lt;code&gt;psychopy_coder_demo.py&lt;/code&gt;を、PsychoPy Coder（Experiment Runner）で実行してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;すると、短い課題が画面に表示されます。この課題を解説していくので、まずは課題をやってみてください。1分で終わります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（Macで）以下のようなエラーが出る場合は、
&lt;a href=&#34;https://discourse.psychopy.org/t/keyboard-psychtoolbox-hid-failing-with-mac-os-catalina-update/9389&#34; title=&#34;Keyboard psychtoolbox/hid failing with Mac OS Catalina update&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;こちらのページ（英語）&lt;/a&gt;を参考にしてください。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;File “psychtoolbox/hid.pyc”, line 137, in init
File “psychtoolbox/hid.pyc”, line 145, in _create_queue
FileNotFoundError: [Errno 2] No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;br&gt;
&lt;h2 id=&#34;実験の構造&#34;&gt;実験の構造&lt;/h2&gt;
&lt;p&gt;実験は終わりましたか？　実験の構造を確認しましょう：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;参加者のIDを入力&lt;/li&gt;
&lt;li&gt;教示が表示される&lt;/li&gt;
&lt;li&gt;Startをクリックすると課題が始まる&lt;/li&gt;
&lt;li&gt;最初に試行数が表示される&lt;/li&gt;
&lt;li&gt;次に都市名が表示される&lt;/li&gt;
&lt;li&gt;どちらの都市の人口が多いかをFかJで回答する&lt;/li&gt;
&lt;li&gt;何もせずに5秒以上経つと「Hurry up!」が表示される&lt;/li&gt;
&lt;li&gt;FかJを押すと、選んだ方の都市が黄色くなり、四角で囲まれる&lt;/li&gt;
&lt;li&gt;正解不正解のフィードバックが表示される&lt;/li&gt;
&lt;li&gt;（裏でその試行のデータが記録される）&lt;/li&gt;
&lt;li&gt;※4〜10を繰り返す&lt;/li&gt;
&lt;li&gt;実験終了のメッセージが表示される&lt;/li&gt;
&lt;/ol&gt;
&lt;br&gt;
&lt;p&gt;では、コードを順になぞっていきます。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;解説&#34;&gt;解説&lt;/h1&gt;
&lt;h2 id=&#34;ダイアログボックスを呈示する3846行目&#34;&gt;ダイアログボックスを呈示する（38–46行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ダイアログボックスを呈示し、参加者の情報を入力
subj_info = {&amp;quot;subj_id&amp;quot;: &amp;quot;&amp;quot;, &amp;quot;add_here_what_you_want&amp;quot;: &amp;quot;&amp;quot;}
dialogue_box = gui.DlgFromDict(subj_info, order = [&amp;quot;subj_id&amp;quot;, &amp;quot;add_here_what_you_want&amp;quot;])

# OKならID（subj_id）を記録して実験を進める。キャンセルなら実験を中止
if dialogue_box.OK:
    subj_id = subj_info[&amp;quot;subj_id&amp;quot;]
else:
    core.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参加者の情報を入力するためのダイアログボックスを呈示しています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add_here_what_you_want&lt;/code&gt;と書いてあるように、他に記録したい情報がある場合は、後ろに付け足してください。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;データファイルの名前を作る5267行目&#34;&gt;データファイルの名前を作る（52–67行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 現在日時を記録
exp_date = data.getDateStr(&amp;quot;%Y%m%d%H%M%S&amp;quot;)

# データファイルを保存するフォルダを作る
# フォルダがなければ作る
try:
    os.makedirs(&amp;quot;data/csv&amp;quot;)
    os.makedirs(&amp;quot;data/log&amp;quot;)
# フォルダが既にある場合は何もしない
except OSError:
    pass

# データファイルの名前を作る（ID_日付）
file_name = subj_id + &amp;quot;_&amp;quot; + exp_date
file_name_csv = os.path.join(&amp;quot;data/csv/&amp;quot; + file_name + &amp;quot;.csv&amp;quot;)
file_name_log = os.path.join(&amp;quot;data/log/&amp;quot; + file_name + &amp;quot;.log&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;参加者のIDと現在日時からファイル名を作っています。プログラムを実行した日時は、何らかの形で記録しておくようにしましょう。&lt;/p&gt;
&lt;p&gt;CSVファイルに行動データ、logファイルに実験のログを記録することにします。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;クイズの項目を読み込む6970行目&#34;&gt;クイズの項目を読み込む（69–70行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# クイズの項目（都市名、人口）を読み込む
city = pd.read_csv(&amp;quot;city.csv&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この実験課題で呈示する項目（CSVファイル）を読み込んでいます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;画面マウスキーボードを設定する7680行目&#34;&gt;画面、マウス、キーボードを設定する（76–80行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 画面の座標系　units = &amp;quot;norm&amp;quot;
# 画面中心が(0, 0)、X軸が-1〜+1、Y軸が-1〜+1
win = visual.Window(width = 1200, height = 900, units = &amp;quot;norm&amp;quot;)
mouse = event.Mouse()
kb = keyboard.Keyboard()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;PsychoPyでは、ふつうスクリーンを&lt;code&gt;win&lt;/code&gt;として記録します。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;都市名刺激を設定する86103行目&#34;&gt;都市名刺激を設定する（86–103行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# テキスト刺激の色と日本語フォント
color_default, color_highlight = &amp;quot;white&amp;quot;, &amp;quot;yellow&amp;quot;
font_ja = &amp;quot;ヒラギノ角ゴシック W3&amp;quot;

# 刺激（都市名）　textは毎試行変わるので、後で定義
city_1_text = visual.TextStim(win, font = font_ja)
city_2_text = visual.TextStim(win, font = font_ja)

# 刺激の呈示位置のカウンターバランス
# 都市名をX軸方向にどれくらいずらすか
city_nudge_x = 0.5
# 4試行のカウンターバランスをcity_posとして保存
city_pos = [&amp;quot;one_two&amp;quot;, &amp;quot;one_two&amp;quot;, &amp;quot;two_one&amp;quot;, &amp;quot;two_one&amp;quot;]
# city_text_posを並び替える
city_pos = np.random.permutation(city_pos)

# 試行の順序をランダマイズする。trial_order: [3, 2, 0, 1]のようになる
trial_order = np.random.permutation(range(len(city)))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;テキスト刺激は&lt;code&gt;visual.TextStim()&lt;/code&gt;で作ります。日本語フォントは好きなものに修正してもらって構いません。&lt;/p&gt;
&lt;p&gt;ここでは、呈示位置のカウンターバランスと、試行順序のランダマイズもしています&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;キーを設定する105112行目&#34;&gt;キーを設定する（105–112行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# キー設定
key_left, key_right = &amp;quot;f&amp;quot;, &amp;quot;j&amp;quot;

# 押すべきキーの名前（課題中に呈示しておく）
# キーのテキストをY軸方向にどれくらいずらすか
key_text_nudge_y = 0.5
key_left_text = visual.TextStim(win, text = &amp;quot;F&amp;quot;, pos = (-city_nudge_x, key_text_nudge_y))
key_right_text = visual.TextStim(win, text = &amp;quot;J&amp;quot;, pos = (city_nudge_x, key_text_nudge_y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Fが左、Jが右に対応するようにしています。&lt;/p&gt;
&lt;p&gt;また、課題中に呈示する「F」と「J」の刺激もここで作っています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;教示を定義する114121行目&#34;&gt;教示を定義する（114–121行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 教示を定義
inst_text = visual.TextStim(win, alignText = &amp;quot;left&amp;quot;, anchorHoriz = &amp;quot;center&amp;quot;)
inst_text.setText(&amp;quot;&amp;quot;&amp;quot;
Which city has a larger population?
Select the city by pressing the F or J of the keyboard.

Click &amp;quot;Start&amp;quot; and work on the task.
&amp;quot;&amp;quot;&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;教示を作っています。日本語だと少しめんどくさいので、英語で書いています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.setText()&lt;/code&gt;を使うと、&lt;code&gt;TextStim&lt;/code&gt;にテキストを埋め込むことができます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;startボタンを定義する123129行目&#34;&gt;Startボタンを定義する（123–129行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ボックスの線の太さ
box_line_width = 10

# 開始ボタンのボックスとテキスト
start_pos_y = -0.5 # Y軸座標
start_box = visual.Rect(win, width = 0.2, height = 0.2, pos = (0, start_pos_y), lineWidth = box_line_width)
start_text = visual.TextStim(win, text = &amp;quot;Start&amp;quot;, pos = (0, start_pos_y))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Startボタンを定義しています。四角形は&lt;code&gt;visual.Rect()&lt;/code&gt;で作ります。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;その他のテキスト刺激や図形を定義する131157行目&#34;&gt;その他のテキスト刺激や図形を定義する（131–157行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 試行間で呈示するテキスト（テキストの中身は毎試行変えるので、後で定義する）
iti_text = visual.TextStim(win)
# ITIの長さ
iti_length = 2

# どちらの都市名を選んだかを何秒呈示するか
confirmation_length = 1
# 選んだ方の都市を囲うボックスを定義
city_box_width, city_box_height = 0.5, 0.2 # ボックスのサイズ
city_box_left = visual.Rect(win,
    width = city_box_width, height = city_box_height, pos = (-city_nudge_x, 0),
    lineColor = color_highlight, lineWidth = box_line_width
)
city_box_right = visual.Rect(win,
    width = city_box_width, height = city_box_height, pos = (city_nudge_x, 0),
    lineColor = color_highlight, lineWidth = box_line_width
)

# 正解不正解のテキスト
correct_text = visual.TextStim(win, text = &amp;quot;Correct!&amp;quot;)
wrong_text = visual.TextStim(win, text = &amp;quot;Wrong...&amp;quot;)
feedback_length = 1

# プロンプトのテキスト
hurry_text = visual.TextStim(win, text = &amp;quot;Hurry up!&amp;quot;, pos = (0, 0.8), color = color_highlight)
# time_limit秒経過したらプロンプトを出す
time_limit = 5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;その他のテキスト刺激や図形を定義しています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;ログファイルを設定する163164行目&#34;&gt;ログファイルを設定する（163–164行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# ログファイルの設定
file_log = logging.LogFile(file_name_log, level = logging.EXP)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;ログファイルを設定しています。実験中に何が起きたかをほぼ自動で記録してくれるので、設定しておくことをおすすめします。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;教示を呈示する170190行目&#34;&gt;教示を呈示する（170–190行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 教示（無限ループ）
while True:

    # Startにカーソルが載ってたら黄色に
    if start_box.contains(mouse):
        start_box.setLineColor(color_highlight)
        start_text.setColor(color_highlight)
    # 載ってなければ白に
    else:
        start_box.setLineColor(color_default)
        start_text.setColor(color_default)

    # 教示とボックスを描画
    inst_text.draw()
    start_box.draw()
    start_text.draw()
    win.flip()

    # 開始ボタンがクリックされたら無限ループを抜ける
    if mouse.isPressedIn(start_box):
        break
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;教示を呈示しています。刺激を&lt;code&gt;draw()&lt;/code&gt;してから&lt;code&gt;win.flip()&lt;/code&gt;するのが基本です。&lt;/p&gt;
&lt;p&gt;Startボタンにカーソルが載ったら色を変えるようにしています。これを応用すると、マウスの位置を記録することができます。&lt;/p&gt;
&lt;p&gt;Startボタンがクリックされたらループを抜けます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;csvファイルの1行目に変数名を書き込む192199行目&#34;&gt;CSVファイルの1行目に変数名を書き込む（192–199行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# CSVファイルの先頭行に変数名を書き込む
with open(file_name_csv, &amp;quot;a&amp;quot;, encoding = &amp;quot;cp932&amp;quot;) as f:
    writer = csv.writer(f, lineterminator = &amp;quot;\n&amp;quot;)
    writer.writerow([
        &amp;quot;subj_id&amp;quot;, &amp;quot;trial&amp;quot;, &amp;quot;city_1&amp;quot;, &amp;quot;city_2&amp;quot;,
        &amp;quot;population_1&amp;quot;, &amp;quot;population_2&amp;quot;, &amp;quot;choice&amp;quot;,
        &amp;quot;correct_answer&amp;quot;, &amp;quot;result&amp;quot;, &amp;quot;rt&amp;quot;, &amp;quot;key&amp;quot;, &amp;quot;pos&amp;quot;
    ])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;CSVファイルに変数名を書き込んでいます。データを記録するときは、この書き方を真似するのがおすすめです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;カーソルを消して課題を始める205215行目&#34;&gt;カーソルを消して課題を始める（205–215行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# カーソルを消す
mouse.setVisible(False)

# 課題開始
for trial_index in range(len(city)):

    # 試行間のテキストを定義して描画
    iti_text.setText(str(trial_index + 1) + &amp;quot;/&amp;quot; + str(len(city)))
    iti_text.draw()
    win.flip()
    core.wait(iti_length)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;カーソルを消してから、試行のループに移っています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;iti_text&lt;/code&gt;を定義し、呈示しています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;core.wait(秒数)&lt;/code&gt;で、プログラムを指定時間止めることができます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;都市名を呈示217244行目&#34;&gt;都市名を呈示（217–244行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 刺激テキストをセット
    city_1 = city[&amp;quot;city_1&amp;quot;][trial_order[trial_index]]
    city_2 = city[&amp;quot;city_2&amp;quot;][trial_order[trial_index]]
    city_1_text.setText(city_1)
    city_2_text.setText(city_2)

    # ついでに人口と正解も記録しておく
    population_1 = city[&amp;quot;population_1&amp;quot;][trial_order[trial_index]]
    population_2 = city[&amp;quot;population_2&amp;quot;][trial_order[trial_index]]
    if population_1 &amp;gt; population_2:
        answer = &amp;quot;city_1&amp;quot;
    else:
        answer = &amp;quot;city_2&amp;quot;

    # 刺激の位置のカウンターバランス
    if city_pos[trial_index] == &amp;quot;one_two&amp;quot;:
        city_1_text.setPos((-city_nudge_x, 0))
        city_2_text.setPos((city_nudge_x, 0))
    else:
        city_1_text.setPos((city_nudge_x, 0))
        city_2_text.setPos((-city_nudge_x, 0))

    # 刺激を描画
    city_1_text.draw()
    city_2_text.draw()
    key_left_text.draw()
    key_right_text.draw()
    win.flip()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;都市名刺激を定義・描画したり、課題に関連するデータを記録したりしています。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;.setPos()&lt;/code&gt;を使うと、刺激の呈示位置を変更することができます。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;開始時間を記録しキーボードをリセット246251行目&#34;&gt;開始時間を記録し、キーボードをリセット（246–251行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 回答を待ち始めた時間をresp_onsetとして記録
    resp_onset = core.Clock()

    # キー押しをリセット
    kb.getKeys([key_left, key_right], waitRelease = False)
    kb.clock.reset()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;刺激呈示の開始時間を記録し、キーボードをリセットしています。&lt;/p&gt;
&lt;p&gt;ここでキーボードをリセットしないと、次の試行にキー押しが引き継がれてしまいます。忘れないようにしましょう。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;回答を待つ253318行目&#34;&gt;回答を待つ（253–318行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 回答を待つ（無限ループ）
    while True:

        # FかJのキー押しを待つ
        key_pressed = kb.getKeys(keyList = [key_left, key_right], waitRelease = False)

        # もしFかJが押されたら
        if len(key_pressed) &amp;gt; 0:

            # 反応時間を記録
            rt = key_pressed[0].rt

            # どっちのキーを押したかをkeyとして記録
            # カウンターバランスに応じて、どっちの都市を選んだかをchoiceとして記録
            if key_pressed[0].name == key_left:
                key = key_left
                if city_pos[trial_index] == &amp;quot;one_two&amp;quot;:
                    choice = &amp;quot;city_1&amp;quot;
                else:
                    choice = &amp;quot;city_2&amp;quot;
            else:
                key = key_right
                if city_pos[trial_index] == &amp;quot;one_two&amp;quot;:
                    choice = &amp;quot;city_2&amp;quot;
                else:
                    choice = &amp;quot;city_1&amp;quot;

            # 結果を記録
            if choice == answer:
                result = &amp;quot;correct&amp;quot;
            else:
                result = &amp;quot;wrong&amp;quot;

            # 選んだ方の都市名を黄色にする
            if choice == &amp;quot;city_1&amp;quot;:
                city_1_text.setColor(color_highlight)
            else:
                city_2_text.setColor(color_highlight)

            # 選んだ方の都市を囲う四角を描画
            if key == key_left:
                city_box_left.draw()
            else:
                city_box_right.draw()

            # その他の刺激も描画して、1秒間呈示
            city_1_text.draw()
            city_2_text.draw()
            key_left_text.draw()
            key_right_text.draw()
            win.flip()
            core.wait(confirmation_length)

            # 刺激の色をリセットし、無限ループから抜ける
            city_1_text.setColor(color_default)
            city_2_text.setColor(color_default)
            break

        # ※time_limitを過ぎたらプロンプトを出す
        if resp_onset.getTime() &amp;gt; time_limit:
            city_1_text.draw()
            city_2_text.draw()
            key_left_text.draw()
            key_right_text.draw()
            hurry_text.draw()
            win.flip()

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;回答を待ちます。反応があったらテキストを黄色にし、四角で囲みます。5秒経過したらプロンプトを出すようにしています。&lt;/p&gt;
&lt;p&gt;コードは長めですが、ここでのキー押し判定や条件分岐は汎用性が高いです。というか、ほとんどの実験はこういう（長い）パーツの組み合わせからできています。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;フィードバックをし各試行のデータを記録320338行目&#34;&gt;フィードバックをし、各試行のデータを記録（320–338行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;    # 正解不正解のフィードバックを呈示
    if result == &amp;quot;correct&amp;quot;:
        correct_text.draw()
    else:
        wrong_text.draw()
    win.flip()
    core.wait(feedback_length)

    # CSVファイルにデータを記録
    with open(file_name_csv, &amp;quot;a&amp;quot;, encoding = &amp;quot;cp932&amp;quot;) as f:
        writer = csv.writer(f, lineterminator = &amp;quot;\n&amp;quot;)
        writer.writerow([
            subj_id, trial_index, city_1, city_2,
            population_1, population_2, choice,
            answer, result, rt, key, city_pos[trial_index]
        ])

    # ログファイルを保存
    logging.flush()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正解不正解のフィードバックを出してから、データを記録しています。&lt;/p&gt;
&lt;p&gt;なお、ここでは日本語（都市名）を記録しているので、&lt;code&gt;encoding = &amp;quot;cp932&amp;quot;&lt;/code&gt;としていますが、ふつうは要らないです。&lt;/p&gt;
&lt;br&gt;
&lt;h2 id=&#34;実験終了344355行目&#34;&gt;実験終了（344–355行目）&lt;/h2&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;# 終わりの画面を定義
finish_text = visual.TextStim(win)
finish_text.setText(&amp;quot;&amp;quot;&amp;quot;
Finish! Thanks!
&amp;quot;&amp;quot;&amp;quot;)

# 3秒呈示してから実験終了
finish_text.draw()
win.flip()
core.wait(3)
win.close()
core.quit()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;終了のメッセージを出して、3秒経過したら実験が終わります。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;
&lt;p&gt;このチュートリアルでは割愛した内容もあります。その中で最も重要なものは「関数の自作」です。関数の自作については、
&lt;a href=&#34;https://qiita.com/snishym/items/8b52db0d901cf5744463&#34; title=&#34;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;PsychoPy Coderによる心理学実験作成チュートリアルまとめ&lt;/a&gt;の第7回を読んでください。&lt;/p&gt;
&lt;p&gt;おそらく、このチュートリアルはわかりにくいです。しかし、ここに載っている機能を使えば、大体の社会心理学実験や意思決定実験のたたき台を作ることはできると思います&lt;sup id=&#34;fnref:3&#34;&gt;&lt;a href=&#34;#fn:3&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;3&lt;/a&gt;&lt;/sup&gt;。かなり駆け足でしたが、このチュートリアルが誰かの役に立てば幸いです。&lt;/p&gt;
&lt;br&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;本当は「いきなり」じゃない、すなわち、ある程度想定できたことなんだけど、なかなか準備できないものです。私もそうでした。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;試行の順序がシャッフルされているので、本来は呈示位置をシャッフルする必要はないです。一応参考のために書いています。 &lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:3&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;そもそも、この（不親切な）説明に付いて来ようとしている時点でかなりモチベーションがあるはずです。プラスアルファで公式のリファレンスを読めば、実用に耐える実験プログラムをすぐに書けるようになると思います。 &lt;a href=&#34;#fnref:3&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>英語を書かなきゃいけないときに使う辞書系ツール</title>
      <link>https://kirikuroda.github.io/post/2020/08/28/english-dictionary/</link>
      <pubDate>Fri, 28 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/08/28/english-dictionary/</guid>
      <description>&lt;h2&gt;目次&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#辞書をあらかじめ決めておく&#34;&gt;辞書をあらかじめ決めておく&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#英英類語辞典&#34;&gt;英英・類語辞典&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#lexico&#34;&gt;LEXICO&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#oxford-learners-dictionaries&#34;&gt;Oxford Learner&amp;rsquo;s Dictionaries&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#コロケーション&#34;&gt;コロケーション&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#just-the-word&#34;&gt;Just the Word&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#netspeak&#34;&gt;Netspeak&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#フレーズ集&#34;&gt;フレーズ集&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#useful-phrases&#34;&gt;Useful Phrases&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#おわりに&#34;&gt;おわりに&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h1 id=&#34;辞書をあらかじめ決めておく&#34;&gt;辞書をあらかじめ決めておく&lt;/h1&gt;
&lt;p&gt;タイトルにもあるように、辞書系ツールを紹介します。しかし正直なところ、自分の使いやすいツールなら何でも良いと思います。&lt;/p&gt;
&lt;p&gt;大事なのは、&lt;strong&gt;使う辞書をあらかじめ決めておく&lt;/strong&gt;ことです。いざ英語を書くときに、使う辞書が決まっていないと、辞書自体を探すところから始まってしまい、時間やエネルギーが奪われます。あるいは「よくわからないからとりあえずググるかー」となった場合、裏のない情報に運悪くトラップされてしまうかもしれません。使う辞書を先に厳選しておけば、そのような事態は避けられます。&lt;/p&gt;
&lt;p&gt;辞書系ツールを選ぶに当たり、以下の3つを選定基準としています。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;無料&lt;/strong&gt;　現状、辞書系ツールに限って言えば、無料で十分だと思います。ただし、専門家じゃないので断言はできません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;オンライン&lt;/strong&gt;　デバイスの環境に依存しないのがメリットです。ただし当然ですが、ネットにつながらないと使えません。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;NO自動翻訳&lt;/strong&gt;　機械学習による自動翻訳ツールは除きました。なるべく自力で文章を書いたほうが、長期的には自分のスキルアップにつながると思うからです。しかし、自動翻訳ツールが発達している今、こういう考えは時代遅れになりつつあるのかもしれません。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;では、辞書系ツールを紹介します。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;英英類語辞典&#34;&gt;英英・類語辞典&lt;/h1&gt;
&lt;h2 id=&#34;lexico&#34;&gt;LEXICO&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.lexico.com&#34; title=&#34;LEXICO&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;LEXICO&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;語義・類語・例文・語源、オールインワンの辞書サイト&lt;/strong&gt;です。Oxford Dictionaryによって運営されているようです。アメリカ英語・イギリス英語、両方とも載っているので、英単語の意味を調べるときは、とりあえずこれで良いと思います。&lt;/p&gt;
&lt;p&gt;特に、類語（シソーラス）を調べるときには、必ずこのサイトを使っています。検索窓のメニューを「THESAURUS」にすると、類語を検索できます。あるいは、各単語のページの「+ Synonyms」をクリックしても、類語を見ることができます。&lt;/p&gt;
&lt;p&gt;例文が多いのも魅力的です。各単語のページの「+ More example sentences」をクリックすると、どういうニュアンスで使われることが多いかを確認できます。&lt;/p&gt;
&lt;h2 id=&#34;oxford-learners-dictionaries&#34;&gt;Oxford Learner&amp;rsquo;s Dictionaries&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.oxfordlearnersdictionaries.com&#34; title=&#34;Oxford Learner&amp;#39;s Dictionaries&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Oxford Learner&amp;rsquo;s Dictionaries&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名前のとおり、英語学習者用の辞書であるため、LEXICOより情報がコンパクトになっています。&lt;strong&gt;単語の意味をさっと確認したいときに便利&lt;/strong&gt;です。また、&lt;strong&gt;平易な英語で語義が説明されている&lt;/strong&gt;ので、LEXICOの説明がわかりにくいときに使うのもおすすめです。頻出単語については、コロケーションや用法も載っています。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;コロケーション&#34;&gt;コロケーション&lt;/h1&gt;
&lt;h2 id=&#34;just-the-word&#34;&gt;Just the Word&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;http://www.just-the-word.com&#34; title=&#34;Just the Word&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Just the Word&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;単語を検索するとコロケーションが表示される&lt;/strong&gt;、というシンプルなサイトです。また、気になったコロケーションをクリックすると、例文も表示されます。コロケーションに関するウェブサイト（そういうのをコーパスっていうんでしょうか？）は他にもありますが、Just the Wordは見た目と機能がシンプルであり、使い方がわかりやすいので気に入っています。&lt;/p&gt;
&lt;h2 id=&#34;netspeak&#34;&gt;Netspeak&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://netspeak.org&#34; title=&#34;Netspeak&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Netspeak&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ある単語や語順の使用頻度を調べたり、比較したりする&lt;/strong&gt;のに使います。たとえば、「atとin、どっちがよく使われるんだろう？」とか、「この副詞は文のどこに置かれることが多いんだろう？」と思ったときに使います。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;フレーズ集&#34;&gt;フレーズ集&lt;/h1&gt;
&lt;h2 id=&#34;useful-phrases&#34;&gt;Useful Phrases&lt;/h2&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.springer.com/jp/book/9783319260921&#34; title=&#34;Useful Phrases&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Useful Phrases&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;英語論文で頻出のフレーズ&lt;/strong&gt;がまとまっています。&amp;ldquo;English for Writing Research Papers&amp;rdquo;（著・Adrian Wallwork：Springer）という、アカデミック・ライティングの書籍&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;の付録です。リンク先にある「Free Download: Useful Phrases」をクリックすると、フレーズ集が載ったPDFをダウンロードできます。&lt;/p&gt;
&lt;p&gt;同様のフレーズ集として、
&lt;a href=&#34;http://www.phrasebank.manchester.ac.uk&#34; title=&#34;Academic Phrasebank&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Academic Phrasebank&lt;/a&gt;というのがあり、結構多くのブログで紹介されています。フレーズの検索性が低いので、私はあまり使っていませんが、有益なサイトの1つだと思います。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;
&lt;p&gt;以上、「英語を書かなきゃいけないときに使う辞書系ツール」を紹介しました。このようなツールを使うと、Google検索でなんとなく英語を調べるよりは、裏づけのある良質な情報を得られると思います。ぜひ、自分にピッタリのツールを探してみてください。&lt;/p&gt;
&lt;br&gt;
&lt;section class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34; role=&#34;doc-endnote&#34;&gt;
&lt;p&gt;この&amp;quot;English for Writing Research Papers&amp;quot;という本は、非常に参考になりました。昨年、『
&lt;a href=&#34;https://bookclub.kodansha.co.jp/product?item=0000275980&#34; title=&#34;ネイティブが教える 日本人研究者のための論文の書き方・アクセプト術&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;ネイティブが教える 日本人研究者のための論文の書き方・アクセプト術&lt;/a&gt;』（講談社、2019）として翻訳されたので、関心のある人は読んでみてください。 &lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
    </item>
    
    <item>
      <title>大学院生が（いまさら）買ってよかったもの8選</title>
      <link>https://kirikuroda.github.io/post/2020/08/25/mustbuy-2020-summer/</link>
      <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/08/25/mustbuy-2020-summer/</guid>
      <description>&lt;h2&gt;目次&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#はじめに&#34;&gt;はじめに&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#iphone-se第2世代&#34;&gt;iPhone SE（第2世代）&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#apple-watch-series-3&#34;&gt;Apple Watch Series 3&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#bellroyのスマホケース&#34;&gt;Bellroyのスマホケース&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#airpods-pro&#34;&gt;AirPods Pro&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#クリアサングラス&#34;&gt;クリアサングラス&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#thermosの真空断熱タンブラー&#34;&gt;THERMOSの真空断熱タンブラー&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#洗顔ネット&#34;&gt;洗顔ネット&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#realforceのキーボード&#34;&gt;REALFORCEのキーボード&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#おわりに&#34;&gt;おわりに&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;h1 id=&#34;はじめに&#34;&gt;はじめに&lt;/h1&gt;
&lt;p&gt;10万円が給付されたので、改めて身の回りのものを買い揃えました。買ってよかったものを8つ紹介します。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;iphone-se第2世代&#34;&gt;iPhone SE（第2世代）&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.apple.com/jp/iphone-se/&#34; title=&#34;iPhone SE&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;iPhone SE（第2世代）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;高校の頃から10年近く使ってきたガラケーにガタが来ていました。これまではiPod touchやiPadでごまかしてきたけれど、ようやく腹をくくってiPhoneを買うことにしました。おおむね便利です。&lt;/p&gt;
&lt;p&gt;しかし、iPhoneを導入してから数日後、外出先で通知を確認するのがめちゃくちゃめんどくさい、というか、通知を見逃しやすいということに気がつきました。ガラケーと違い、通知のバイブレーションが短くて弱すぎたのです。&lt;/p&gt;
&lt;p&gt;この「通知気づきにくい問題」に対処するため、Apple Watchを買いました。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;apple-watch-series-3&#34;&gt;Apple Watch Series 3&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.apple.com/jp/apple-watch-series-3/&#34; title=&#34;Apple Watch Series 3&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Apple Watch Series 3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;買う当初は「スマートウォッチって贅沢すぎでは？」と思っていましが、使っているうちに、この1年でベスト3くらいの買い物だと考えを改めることになりました。以下の3つが特に便利です。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;必ず通知に気づく&lt;/strong&gt;：当初の計画通り、通知を見逃さずに済むようになりました。また、必ず通知に気づくようになったことで、メールやメッセージアプリを確認する回数、すなわち、無駄にデバイスを見る時間が減りました。これは時間の節約になるし、精神的な疲労の軽減にもつながると思います。Twitter等のSNSをやっている人だと、この時短効果はより大きいのではないでしょうか。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;支払いが楽&lt;/strong&gt;：Apple WatchにモバイルSuicaを入れておけば、レジの読み取り機や自動改札機にタッチするだけで決済できるようになります。スマホだけでもキャッシュレス決済はできるけれど、いちいちスマホを取り出さずに済むのは予想以上に楽です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ライフログを取れる&lt;/strong&gt;：これは贅沢かもしれないですが、なんとなくライフログを取ることにしました。Autosleep（自動で睡眠時間を記録してくれるアプリ）とLife Cycle（いつ、どこら辺にいたかを記録してくれるアプリ）を使っています。よく運動をする人であれば、この他にも活用法を見いだせると思います。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;逆に、スマートウォッチを持っていない人は、どうやって通知を確認しているのでしょうか？　いちいちスマホを開くのが無駄だと感じている場合は、購入を考えても良いかもしれません。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;bellroyのスマホケース&#34;&gt;Bellroyのスマホケース&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://ja.bellroy.com/products/phone-case-3-card/leather_iphone_se/caramel#slide-0&#34; title=&#34;Phone Case – 3 Card&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Phone Case – 3 Card&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名前の通り、背面にカードを3枚入れられるスマホケースです。このケースの中に、クレジットカード・学生証・大学生協の組合員証を入れています。これのおかげで財布をほぼ使わなくなったし、近場に行くときには財布を持つことすらなくなりました。&lt;/p&gt;
&lt;p&gt;このスマホケースは10000円します。カードを入れられるスマホケースで、もっと安いものはいくらでも見つかると思います。実際、私も「さすがに贅沢では」と悩みましたが、ふだん安物買いの銭失いで失敗することが多いので、思い切って買うことにしました。長く使いたいです。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;airpods-pro&#34;&gt;AirPods Pro&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.apple.com/jp/airpods-pro/&#34; title=&#34;AirPods Pro&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;AirPods Pro&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;めちゃくちゃ良いです。ノイズキャンセリング性能が良いのはもちろんのこと、装着感が軽いのが何より素晴らしいです。自分は音楽をほぼ聞かないし、かなりいい値段もするけれど、それでも買って良かったと思います。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;クリアサングラス&#34;&gt;クリアサングラス&lt;/h1&gt;
&lt;p&gt;日差しがまぶしすぎるので、例年、夏になるとサングラスをかけています。しかし、今年はマスクを着けなければいけないので、サングラスをかけると不審者に見えてしまうという問題が生じました。&lt;/p&gt;
&lt;p&gt;そこで、クリアサングラス（透明なサングラス）を買いました。見た目にはふつうの眼鏡なので、マスクと合わせても不審者感は全くないです。地味にいい買い物でした。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;thermosの真空断熱タンブラー&#34;&gt;THERMOSの真空断熱タンブラー&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.shopthermos.jp/shop/g/g350059280500/&#34; title=&#34;真空断熱タンブラー JDM-420 ブラック&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;真空断熱タンブラー&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;真空断熱タンブラーこそ、「地味に生活のクオリティを上げてくれるアイテム」の筆頭だと思います。これまで2年くらい、サーモスのステンレス製タンブラーを使ってきました。今回買い替えたのは、（おそらく）経年劣化のために保冷効果が弱まってきたからです。&lt;/p&gt;
&lt;p&gt;今までのステンレス製とは違い、今回買ったのは陶器っぽいマットな仕上がりで、飲み口も柔らかくなっています。他にも色や素材にバリエーションがあるので、気になった方は調べてみてください。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;洗顔ネット&#34;&gt;洗顔ネット&lt;/h1&gt;
&lt;p&gt;持っている人からしたら当たり前のことですが、洗顔ネットを使うと「どこにこんな泡があったんだ！？」というレベルでもこもこ泡立ちます。はじめて使ったとき、この数ヶ月で一番びっくりしました。値段も全然高くないし、一度買えば数年から一生は使えると思うので、買ってよかったです。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;realforceのキーボード&#34;&gt;REALFORCEのキーボード&lt;/h1&gt;
&lt;p&gt;
&lt;a href=&#34;https://www.realforce.co.jp/products/R2TLSA-US3M-WH/&#34; title=&#34;REALFORCE TKL SA for Mac / R2TLSA-US3M-WH&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;REALFORCE TKL SA for Mac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REALFORCEというのは、有名なキーボードブランドの1つです。HHKBというブランドもありますが、個人的には、REALFORCEのほうが軽くて好みです。&lt;/p&gt;
&lt;p&gt;それなりに文章に接する職業の人間、すなわち博士課程の院生なら、高めのキーボードを買ったほうが良いと思います。ふつうのキーボードより手への負担が減るだけでなく、文章を書くこと自体がなんとなく楽しくなります。&lt;/p&gt;
&lt;p&gt;ちなみに、同じメーカーでもキーボードの種類が多いので、買うときは公式サイトやネットの情報をよく調べるようにしてください。&lt;/p&gt;
&lt;br&gt;
&lt;h1 id=&#34;おわりに&#34;&gt;おわりに&lt;/h1&gt;
&lt;p&gt;どのアイテムもそれなりに贅沢ですが、地味に、でも確実に生活のクオリティを上げてくれます。いいものを買ってるので、それに見合った仕事をしたいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>データの可視化 まとめ</title>
      <link>https://kirikuroda.github.io/post/2020/08/22/datareporting/</link>
      <pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/08/22/datareporting/</guid>
      <description>&lt;p&gt;数年前のことですが、データ可視化・報告・ggplot2の初歩をまとめました。
&lt;a href=&#34;https://kirikuroda.github.io/datareporting/&#34; title=&#34;「いつか役に立つかもしれない資料」&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;こちら&lt;/a&gt;で読むことができます。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Hugo Academicでウェブサイトをリニューアルしました</title>
      <link>https://kirikuroda.github.io/post/2020/08/21/hugo-academic/</link>
      <pubDate>Fri, 21 Aug 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/post/2020/08/21/hugo-academic/</guid>
      <description>&lt;p&gt;2年ぶりにウェブサイトをリニューアルしました。リニューアルにあたり、かねがね気になっていた
&lt;a href=&#34;https://themes.gohugo.io/academic/&#34; title=&#34;Hugo Academic&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;Hugo Academic&lt;/a&gt;というテンプレートと、
&lt;a href=&#34;https://bookdown.org/yihui/blogdown/&#34; title=&#34;blogdown: Creating Websites with R Markdown&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt;blogdown&lt;/a&gt;（Rのパッケージ）を使うことにしました。&lt;/p&gt;
&lt;p&gt;サイト構築の詳しい手順は説明しませんが、1日から2日で一通り作ることができました。もう少し時間をかければ、配色やフォントを自分好みにカスタマイズできそうです。&lt;/p&gt;
&lt;p&gt;そこまで労せずして、自分にしてはオシャレ（？）なサイトを作ることができて良かったです。くわえて、Markdown / R Markdownで記事を書くことができるのも嬉しいポイントです。気が向いたらなにか書きたいです。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Investor&#39;s Pessimistic and False Belief About Trustworthiness and Stake Size in Trust Decision</title>
      <link>https://kirikuroda.github.io/publication/kuroda2020investor/</link>
      <pubDate>Wed, 15 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/publication/kuroda2020investor/</guid>
      <description></description>
    </item>
    
    <item>
      <title>You Watch My Back, I&#39;ll Watch Yours: Emergence of Collective Risk Monitoring Through Tacit Coordination in Human Social Foraging</title>
      <link>https://kirikuroda.github.io/publication/kuroda2019you/</link>
      <pubDate>Sun, 01 Sep 2019 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/publication/kuroda2019you/</guid>
      <description></description>
    </item>
    
    <item>
      <title>The Perception of Spontaneous and Volitional Laughter Across 21 Societies</title>
      <link>https://kirikuroda.github.io/publication/bryant2018perception/</link>
      <pubDate>Wed, 25 Jul 2018 00:00:00 +0000</pubDate>
      <guid>https://kirikuroda.github.io/publication/bryant2018perception/</guid>
      <description></description>
    </item>
    
  </channel>
</rss>
